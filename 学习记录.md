# Git

## git clone

一般是用 git clone 命令把远程的 repo 克隆到本地

```shell
git clone -b  特定分支 http/ssh地址
```

通常 `clone` 一个代码，默认的远程仓库的名字就是 `origin`。

## git remote

用于管理远程仓库

```shell
git remote -v //查看远程仓库详细信息                                 
origin	git@GitHub.com:ChinglinTHU/git-test.git (fetch) # 默认远程的名字就是 origin
origin	git@GitHub.com:ChinglinTHU/git-test.git (push)
```

### 修改远程仓库：

默认仓库`origin`的名字时可以**修改**的

```shell
git remote rename origin test
git remote -v 
#test	git@GitHub.com:ChinglinTHU/gittest.git (fetch)
#test	git@GitHub.com:ChinglinTHU/gittest.git (push)
```

### **添加远程仓库:**

```shell
git remote add testa git@GitHub.com:ChinglinTHU/git-test-a.git
git remote add testb git@GitHub.com:ChinglinTHU/git-test-b.git
git remote -v                                                 
test	git@GitHub.com:ChinglinTHU/git-test.git (fetch)
test	git@GitHub.com:ChinglinTHU/git-test.git (push)
testa	git@GitHub.com:ChinglinTHU/git-test-a.git (fetch)
testa	git@GitHub.com:ChinglinTHU/git-test-a.git (push)
testb	git@GitHub.com:ChinglinTHU/git-test-b.git (fetch)
testb	git@GitHub.com:ChinglinTHU/git-test-b.git (push)
```

`add `的方式就是在原来基础上添加。不会改变远来的远程仓库。添加之后需要 `pull`，才能在本地看到对应 repo 的信息：

```shell
git pull testa    
remote: Enumerating objects: 8, done.
remote: Counting objects: 100% (8/8), done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (6/6), done.
remote: Total 6 (delta 0), reused 3 (delta 0), pack-reused 0
From GitHub.com:ChinglinTHU/git-test-a
 * [new branch]      main       -> testa/main
 * [new branch]      testa1     -> testa/testa1
You asked to pull from the remote 『testa』, but did not specify
a branch. Because this is not the default configured remote
for your current branch, you must specify a branch on the command line.
```

### **删除远程仓库：**

```shell
git remote remove testb
git remote -v                                                 
test	git@GitHub.com:ChinglinTHU/git-test.git (fetch)
test	git@GitHub.com:ChinglinTHU/git-test.git (push)
testa	git@GitHub.com:ChinglinTHU/git-test-a.git (fetch)
testa	git@GitHub.com:ChinglinTHU/git-test-a.git (push)
```

## git pull和git push

配置了远程仓库之后，就要进行代码的拉取和推送。首先在本地新建立一个分支：

```shell
git checkout -b local
```

### 1. 代码推送

```shell
git push test local:local
```

將本地 `local `分支的代码推送到远程的 `local `分支，前面的 `test `就是指远程仓库的名字。第一个 `local `是本地分支的名字，第二个 `local `是远程分支的名字。名字不一定是 lcoal，其它名字都可以的。

```shell
git push//不规范，省略版
```

这里运行 `git push `时候省略了一些参数。通常我们只有一个远程 repo，所以就默认推送到了远程的 `origin `这个地方。分支的话，就是推送远当前分支到远程分支，如果远程分支上没有当前分支，还需要我们设定远程分支的 `upstream`。

- 如果没有设定远程仓库的名字，就默认推送当前分支绑定的远程分支，如果没有绑定的远程分支，则会报错。
- 如果没有设定分支名字，则自动推送当前分支到远程 repo 中同名的分支中去。

**奇怪的操作，在本地删除远程分支：**

通常我们删除远程的分支是在 git 的服务器端（如 GitLab 的网页，GitHub 的网页）进行的，实际上我们也可以通过推送一个空白的分支到某一个远程分支，实现删除某一个远程分支的目的。

```shell
git push test :test1       
To GitHub.com:ChinglinTHU/git-test.git
 - [deleted]         test1
```

### 2. 把远程一个分支代码拉取到本地

```shell
git pull testa remotebranch:localbranch
```

使用方式和本地分支推送到远程分支的方式类似。

`git pull`命令是一个高层次的命令，它相当于`git fetch`和`git merge`两个命令的组合。简而言之，`git pull`用于从远程仓库拉取更新并将它们合并到当前分支。

```bash
git pull <remote> <branch>
```

这个命令会从指定的远程仓库（`<remote>`）拉取指定分支（`<branch>`）的更新，然后将这些更新合并到当前所在的分支

`git pull`的机制可以分为两步：

- **Fetch**: 从远程仓库拉取更新到本地，这个步骤实际上是执行了`git fetch`。
- **Merge**: 将从远程仓库拉取的更新合并到当前分支，这相当于执行了`git merge`

## git fetch

 `git fetch`命令则是用于从远程仓库获取更新，但它不会自动合并到当前分支。相反，它将获取的更新保存在本地，让你可以在需要的时候进行合并操作。

```bash
git fetch <remote> <branch>
```

与`git pull`不同，`git fetch`只会将远程仓库的更新下载到本地，并不会直接影响当前分支。

### git fetch --prune

**强制刷新远程分支缓存**
执行 `git fetch --prune` 命令，该命令会拉取远程所有分支的最新状态，并清理本地缓存中已不存在的远程分支记录

## git rebase 和git merge

### 基本概念

1. **Merge**：合并两个分支的历史记录，保留分支合并的轨迹。Merge操作会创建一个新的合并提交（merge commit），这个提交有两个父提交。
2. **Rebase**：将一个分支的提交重新应用到另一个分支上，不保留分支合并的轨迹。Rebase操作会重新写历史，创建新的提交而不是合并提交。

### Merge操作的基本流程如下：

```bash
# 假设当前在feature分支，需要合并到main分支。将feature合并到main，有历史记录
git checkout main
git merge feature
```

- **结果**：在main分支上创建一个新的合并提交，保留两个分支的提交历史。
- **优点**：
  - 保留了分支的合并历史，清晰地展示了分支结构。
  - 简单易用，适合大多数合并场景。
- **缺点**：
  - 可能会导致提交历史变得复杂，特别是频繁合并时。

### Rebase操作的基本流程如下：

```bash
# 假设当前在feature分支，需要将其rebase到main分支上。将feature的修改移到main上，feature历史不可查
git checkout feature
git rebase main
```

- **结果**：将feature分支上的提交重新应用到main分支的顶部，历史记录将被重写。
- **优点**：
  - 提交历史更加线性和清晰，便于阅读和管理。
  - 消除了不必要的合并提交，使历史记录简洁。
- **缺点**：
  - 重写历史可能会导致冲突，需要手动解决。
  - 对已经共享的分支进行rebase可能会导致问题，不适合公开仓库。

## git stash

 git stash 单次记录的操作是 Git 中非常实用的功能，用于临时搁置当前的工作进度。下面我将为你详细解释如何操作单条 stash 记录。

**核心概念：Stash 作为堆栈**
        首先，git stash 的工作方式像一个堆栈 (Stack)——后进先出 (LIFO: Last In, First Out)。你每次执行 git stash（或 git stash push）都会将当前未提交的修改压入这个堆栈，形成一条记录。

#### 创建一条新的 Stash 记录（最基本）

```bash
# 在项目的根目录下执行
git stash
# 等同于（较新版本的Git）
git stash push
# 推荐：添加一段描述信息，便于日后识别
git stash push -m "正在开发登录功能，临时修复紧急bug"
```

​    这是最常用的命令，它会将**当前工作目录和暂存区**的修改保存为一条新的 stash 记录。

**效果**：你的工作目录会变得干净，回到上一次提交的状态。所有未提交的修改都被打包成一条 stash 记录，并放在堆栈的顶部（最新位置）。

恢复（应用）某一条特定的 Stash 记录
        默认的 **git stash pop** 会应用最新的 stash@{0} 并删除它。如果你想应用一条特定的旧记录，并保留它：

```bash
# 应用指定的 stash 记录，但不从堆栈中删除
git stash apply stash@{1}
# 应用最新的 stash，等同于 `git stash apply stash@{0}`
git stash apply
```

提示：apply 命令不会自动删除这条记录，它还会留在列表中。
查看现有的 Stash 列表
        要操作单条记录，首先得知道有哪些记录。

### **查看 stash 堆栈的列表摘要**

`git stash list`

**显示更详细的信息（如具体的文件变更）**

```bash
git stash list --stat
//输出示例：
stash@{0}: On main: 正在开发登录功能，临时修复紧急bug
stash@{1}: On main: 实验性代码，尝试新API
stash@{2}: On main: WIP on feature-branch
```

stash@{0} 是最新（最近）的记录。

stash@{1} 是上一次的记录，依此类推。

On main 表示创建 stash 时所在的分支是 main。

# 进程

## 一、fork()函数

```c
头文件
#include<unistd.h>
#include<sys/types.h>

函数原型
   pid_t fork(void);
  （pid_t 是一个宏定义，其实质是int 被定义在#includesys/types.h>中）
   返回值：若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1
```

## 二、wait()和waitpid()函数

```c
#include<sys/types.h>
#include<sys/wait.h>

函数原型:pid_t wait(int *status);
返回值：
	成功:返回结束的子进程pid，终止回收子进程,
	失败:返回-1(没有子进程)失败原因存于errno 中
参数：
  	(1)wait()会暂时停止目前进程的执行, 即阻塞父进程，等待子进程结束或者其他信号. 
  	(2)如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 
  	(3)子进程的结束状态值会由参数status返回, 而子进程的进程识别码也会一并返回. 
  	(4)如果不考虑结束状态值, 则参数 status 可以设成NULL.

函数原型:pid_t waitpid(pid_t pid, int *status, int options);
返回值:
   	正常:返回已成功结束运行的子进程的进程号
   	使用选项WNOHANG且没有子进程退出:0
	失败:-1
参数
	(1)pid:
		pid > 0|只等待进程ID等于pid的子进程，不管其他子进程是否结束，只要指定子进程未结束，waitpid()就会一直等下去
		pid =-1|等待任何一个子进程退出，此时和wait()作用一样
		pid = 0|等待其组ID等于调用进程的组ID的任一子进程
		pid <-1|等待其组ID等于pid的绝对值的任一子程序
	(2)options:
		WNOHANG:若pid指定的子进程未结束，则waitpid()不阻塞父进程，立即返回0；
		WUNTRACED:若pid指定进程已被暂停，且其状态自暂停以来还未报告过，则返回其状态
		0:同wait(),阻塞父进程，等待子进程退出
	(3)stasus: 同wait
```

## 三、exec族

我们直到一个进程被创建出来，OS会给它分配进程PCB，mm_struct,页表等信息，同时会将程序的代码和数据加载到物理内存；而进程程序替换就是：正在执行的进程本身的pcb,mm_struct，页表等信息不会发生改变，仅仅把一个新的程序代码和数据替换了原来进程的代码和数据；这就是进程程序的替换

**进程程序替换并不会创建新的进程，它只会加载程序的代码和数据，去替换原来的进程！！！**

**程序替换函数，通常不父进程去执行，而是交给子进程执行，因为这也子进程可以做它的事，父进程也可以做自己的事，由于进程之间的独立性，即使子进程去执行execl函数时候，替换的也是子进程的代码和数据，而父进程的代码和数据是不会被影响的；**

```c
#include <unistd.h>` //exec函数族的头文件

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ...,char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path,char *const argv[],char *const envp[]);

1.这些函数如果调用成功则加载新的程序从启动代码开始执行,不再返回；
2.如果调用出错则返回-1；
3.所以exec函数只有出错的返回值而没有成功的返回值
```

```c
l(list) : 表示参数采用列表；
v(vector) : 参数用数组；
p(path) : 有p自动搜索环境变量PATH；
e(env) : 表示自己维护环境变量；
```



## 四、exit()/_exit()

exit()和_exit()都是用来无条件中止进程

调用exit()比\_exit()时多做了些清理、保存工作，最后执行exit()中止进程执行；而_exit()则是直接执行exit()中止进程执行。

![img](https://img-blog.csdn.net/20150912223419302)

## 一、管道

管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。

#### 1、特点：

它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。

它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。

它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。


#### 2、原型：

```c
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```

当一个管道建立时，它会创建两个文件描述符：`fd[0]`为读而打开，`fd[1]`为写而打开。

单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。

若要数据流从父进程流向子进程，则关闭父进程的读端（`fd[0]`）与子进程的写端（`fd[1]`）；反之，则可以使数据流从子进程流向父进程。

## 二、FIFO

FIFO，也称为命名管道，它是一种文件类型。

#### 1、特点

1. FIFO可以在无关的进程之间交换数据，与无名管道不同。
2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

#### 2、原型

```c
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。

当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：

若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。

若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。


## 三、消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

#### 1、特点

消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。

消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。

消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

#### 2、原型

```c
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
```

**`key`**：消息队列的唯一标识符（用 `ftok()` 生成，或用 `IPC_PRIVATE` 创建私有队列）

**`flag`**：权限标志（类似文件权限），可取：

- `IPC_CREAT`：若队列不存在，则创建
- `IPC_EXCL`：与 `IPC_CREAT` 结合使用，若已存在则失败
- 权限位：如 `0666`（用户可读写，组可读写，其他可读写）

```c
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
```

**`msqid`**：消息队列 ID（由 `msgget()` 获得）

**`ptr`**：指向消息结构体的指针（必须包含 `long mtype;` 开头）

**`size`**：消息正文大小（不包括 `mtype`）

**`flag`**：

- `0`：默认阻塞
- `IPC_NOWAIT`：非阻塞，若队列已满则立即返回错误

```c
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
```

**`msqid`**：消息队列 ID

**`ptr`**：指向接收消息的结构体指针（和发送端结构一样）

**`size`**：接收的正文最大长度

**`type`**：

- `0`：接收队列中的第一个消息
- `>0`：接收**类型等于 `msgtyp`** 的第一个消息
- `<0`：接收**类型小于等于 `|msgtyp|`** 的最小类型的消息

**`flg`**：

- `0`：默认阻塞
- `IPC_NOWAIT`：非阻塞
- `MSG_NOERROR`：如果消息太长，就截断（不报错）

```c
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

**`cmd`**：

- `IPC_STAT`：获取队列状态，写入 `buf`
- `IPC_SET`：设置队列参数（如权限），从 `buf` 读
- `IPC_RMID`：删除队列

**`buf`**：指向 `struct msqid_ds` 结构体的指针（包含权限、统计信息等）

在以下两种情况下，msgget将创建一个新的消息队列：

如果没有与键值key相对应的消息队列，并且flag中包含了IPC_CREAT标志位。
key参数为IPC_PRIVATE。
函数msgrcv在读取消息队列时，type参数有下面几种情况：

type == 0，返回队列中的第一个消息；
type > 0，返回队列中消息类型为 type 的第一个消息；
type < 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。
可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。

## 四、信号量

```c
#include<sys/sem.h>
//创建或获取信号量集
int semget(key_t key, int nsems, int semflg);
```

| 参数     | 含义                                        |
| -------- | ------------------------------------------- |
| `key`    | 使用 `ftok()` 生成的键值                    |
| `nsems`  | 信号量的数量（通常为 1）                    |
| `semflg` | 权限（如 `0666`）+ 标志位（如 `IPC_CREAT`） |

```c
//对信号量执行操作（加锁/解锁）
int semop(int semid, struct sembuf *sops, size_t nsops);
```

```c
struct sembuf {
    unsigned short sem_num;  // 信号量编号（第几个）
    short sem_op;            // 操作：-1为P（等待），+1为V（释放）
    short sem_flg;           // 操作标志，如 0、IPC_NOWAIT、SEM_UNDO
};
```

| 字段      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| `sem_num` | 信号量编号（从0开始）                                        |
| `sem_op`  | 操作类型： - `-1`：P操作（等待，减1） - `+1`：V操作（释放，加1） - `0`：阻塞直到该信号量为0 |
| `sem_flg` | 选项： - `0`：阻塞等待 - `IPC_NOWAIT`：不阻塞 - `SEM_UNDO`：若进程异常退出，自动还原改动 |

`struct sembuf *sops`：这是一个 **信号量操作结构体数组的指针**，每个 `sembuf` 结构表示一个对信号量的操作。

`nsops`：表示 `sops` 数组中操作的数量。即你希望同时执行几个信号量操作。

```c
//控制信号量（设置、获取值或删除）
int semctl(int semid, int semnum, int cmd, ...);
```

| 参数     | 含义                            |
| -------- | ------------------------------- |
| `semid`  | 信号量集 ID（由 `semget` 得到） |
| `semnum` | 信号量编号（第几个信号量）      |
| `cmd`    | 控制命令，如下                  |

| 常用命令   | 作用                             |
| ---------- | -------------------------------- |
| `SETVAL`   | 设置某个信号量的值（配合 union） |
| `GETVAL`   | 获取某个信号量的值               |
| `IPC_RMID` | 删除整个信号量集                 |

例子：同时对多个信号量操作

```c
struct sembuf sops[2];

// P操作 信号量0
sops[0].sem_num = 0;
sops[0].sem_op = -1;
sops[0].sem_flg = SEM_UNDO;

// P操作 信号量1
sops[1].sem_num = 1;
sops[1].sem_op = -1;
sops[1].sem_flg = SEM_UNDO;

// 原子执行两个P操作
semop(semid, sops, 2);
```

#### 最外层：`union semun`//向csemctl（）函数传递参数

```c
union semun {
    int              val;    // 用于 SETVAL
    struct semid_ds *buf;    // 用于 IPC_STAT / IPC_SET
    unsigned short  *array;  // 用于 SETALL / GETALL
};
```

这是一个 **联合体（union）**，用于向 `semctl()` 函数传递参数，**根据 semctl 的 cmd 命令使用其中一个成员**。

| 成员名  | 类型                | 用法                                                         |
| ------- | ------------------- | ------------------------------------------------------------ |
| `val`   | `int`               | 用于 `SETVAL` —— 设置单个信号量的值                          |
| `buf`   | `struct semid_ds *` | 用于 `IPC_STAT`、`IPC_SET` —— 获取或设置信号量集属性         |
| `array` | `unsigned short *`  | 用于 `SETALL`、`GETALL` —— 设置/获取信号量集中每个信号量的值 |

第二层：`struct semid_ds`

当用 `arg.buf = &my_ds;` 时，`my_ds` 的类型就是：

```c
struct semid_ds {
    struct ipc_perm sem_perm;  // 权限信息结构体
    time_t sem_otime;          // 上次 semop() 的时间
    time_t sem_ctime;          // 上次 semctl() 的时间
    unsigned long sem_nsems;   // 信号量集中的信号量数量
};
```

这是 **信号量集的元信息结构体**，可以通过它：

- 查看权限（sem_perm）
- 查看或设置信号量数量
- 查看操作时间

第三层：`struct ipc_perm`

这是 `sem_perm` 成员，它描述“这个信号量集的访问权限”，**跟文件权限非常类似**。

```c
struct ipc_perm {
    key_t __key;       // 由 ftok() 生成的 key 值
    uid_t uid;         // 所有者用户ID
    gid_t gid;         // 所有者组ID
    uid_t cuid;        // 创建者用户ID
    gid_t cgid;        // 创建者组ID
    mode_t mode;       // 访问权限（如 0666）
    unsigned short __seq;  // 序列号（系统使用）
};
```

| 字段        | 说明                                      |
| ----------- | ----------------------------------------- |
| `__key`     | 唯一标识 IPC 对象的 key，由 `ftok()` 生成 |
| `uid/gid`   | 当前拥有者的 UID / GID                    |
| `cuid/cgid` | 创建者的 UID / GID                        |
| `mode`      | 权限位，跟 Linux 文件一样，如 `0666`      |
| `__seq`     | 序列号，系统内部使用，一般不改            |

```c
union semun {
  ├── int val                    // SETVAL
  ├── struct semid_ds *buf      // IPC_STAT / IPC_SET
  │     ├── struct ipc_perm sem_perm
  │     │     ├── key_t __key
  │     │     ├── uid_t uid
  │     │     ├── mode_t mode
  │     │     └── ...
  │     ├── time_t sem_otime
  │     └── unsigned long sem_nsems
  └── unsigned short *array     // SETALL / GETALL
```

## 五、共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。

#### 1、特点

共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

因为多个进程可以同时操作，所以需要进行同步。

信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

#### 2、原型

```c
#include<sys/shm.h>
//创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
int shmget(key_t key, size_t size, int shmflg);
```

| 参数     | 类型     | 含义                                                         |
| -------- | -------- | ------------------------------------------------------------ |
| `key`    | `key_t`  | 与其他进程共享的标识符（通常用 `ftok()` 生成）               |
| `size`   | `size_t` | 要分配的共享内存大小（单位：字节）                           |
| `shmflg` | `int`    | 标志位，用于指定权限和行为（如 `IPC_CREAT`, `IPC_EXCL`, 权限位） |

```c
// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
void *shmat(int shm_id, const void *addr, int shmflg);
```

| 参数      | 类型           | 说明                                     |
| --------- | -------------- | ---------------------------------------- |
| `shmid`   | `int`          | 由 `shmget()` 获取的共享内存 ID          |
| `shmaddr` | `const void *` | 映射地址（一般传 `NULL` 让系统自动选择） |
| `shmflg`  | `int`          | 标志位（常用 0 或 `SHM_RDONLY`）         |

| 值           | 含义                                                       |
| ------------ | ---------------------------------------------------------- |
| `0`          | 默认，可读写                                               |
| `SHM_RDONLY` | 映射为只读                                                 |
| `SHM_RND`    | 地址 `shmaddr` 将按 `SHMLBA`（系统页面边界）对齐（不常用） |

```c
// 断开与共享内存的连接：成功返回0，失败返回-1
int shmdt(void *addr);
```

| 参数      | 类型     | 说明                              |
| --------- | -------- | --------------------------------- |
| `shmaddr` | `void *` | 之前 `shmat()` 返回的共享内存地址 |

```c
// 控制共享内存的相关信息：成功返回0，失败返回-1
int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
```

| 参数    | 含义                                                        |
| ------- | ----------------------------------------------------------- |
| `shmid` | 共享内存段的 ID，由 `shmget()` 返回                         |
| `cmd`   | 要执行的控制命令（见下表）                                  |
| `buf`   | 指向 `struct shmid_ds` 结构体的指针，存储共享内存信息或设置 |

常用cmd命令

| 宏         | 含义               | 用途                               |
| ---------- | ------------------ | ---------------------------------- |
| `IPC_STAT` | 获取共享内存信息   | 将共享内存信息填入 `*buf`          |
| `IPC_SET`  | 修改权限和用户信息 | 用 `*buf` 中的内容更新共享内存属性 |
| `IPC_RMID` | 删除共享内存段     | 通知系统删除该段（并非立即）       |

```c
struct shmid_ds {
    struct ipc_perm shm_perm;  // 权限和拥有者信息
    size_t shm_segsz;          // 共享内存大小（字节）
    time_t shm_atime;          // 最后一次附加时间
    time_t shm_dtime;          // 最后一次分离时间
    time_t shm_ctime;          // 最后一次更改时间
    pid_t shm_cpid;            // 创建该段的进程 PID
    pid_t shm_lpid;            // 最后操作该段的进程 PID
    shmatt_t shm_nattch;       // 当前附加到该段的进程数
};
```

# Linux文件操作

## 一、open（）函数：

```c
头文件
#include <fcntl.h>
int open(const char *pathname, int flags, mode_t mode);

返回一个文件描述符，当文件成功打开时，返回一个非负整数，当文件打开失败时，返回-1
```

参数：
const char *pathname：

文件路径名（绝对路径）或者文件名

int flags：

选择打开文件的操作，分别为：

● O_RDONLY   只读

● O_WRONLY   只写

● O_RDWR  可读可写

当然我们可以与上另外一些可选常量，展示不同的功能：

如：O_RDWR | O_CREAT    可读可写且当打开这个文件时，该文件不存在则创建它

● O_CREAT      当打开这个文件时，该文件不存在则创建它，需要搭配第三个参数使用

● O_APPEND     每次往这个文件写新的内容时，新的内容总是加到文件的末端

即打开文件后进行写操作时（调用write（）），若该文件原先有内容，则不会覆盖原来的内容，而是在末端添加内容

● O_TRUNC      清空内容         

● O_EXCL       若同时与上该常量与 O_CREAT，当需要打开的文件存在时，open（）会返回一个整型数-1

mode_t mode：（可选参数）

文件访问权限的初始值：（0xxx）

可读 r：  4

可写 w： 2

执行 x：  1



## 二、write（）函数：

``` c
头文件
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);

写入成功时，返回写入的字节数（零表示没有任何内容）
如果const void *buf为零，并且fd引用常规文件，则write（）可能会返回-1
如果检测到，或未执行错误检测，则将返回0，而不进行任何更改
```

参数：

int fd：使用open（）时返回的文件描述符

void \*buf：内存，一般传内存地址，如数组名，指针名）

size_t count：写入字节数

## 三、read（）函数

```c
头文件
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);

成功时，返回读取的字节数（零表示结束），出现错误时，返回-1
```

参数：

int fd：使用open（）时返回的文件描述符

void \*buf：内存，一般传内存地址，如数组名，指针名

size_t count：读取字节数

## 四、close（）函数：

```c
头文件
#include <unistd.h>
    
close(int fd);
关闭文件
```

## 五、lseek（）函数

```
头文件
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

参数 offset(偏移)的含义取决于参数 whence（根源，从何处）：

1） 如果 whence 是 SEEK_SET，则返回的文件偏移量将被设置为 offset。

 2.）如果 whence 是 SEEK_CUR，则返回的文件偏移量将被设置为 cfo（当前文件偏移量（current file offset）） 加上 offset（偏移量）， offset 可以为正也可以为负。

 3.）如果 whence 是 SEEK_END，则返回的文件偏移量将被设置为文件长度加上 offset，offset 可以为正也可以为负。

a、 欲将读写位置移到文件开头时:

lseek（int fildes,0,SEEK_SET）；

b、欲将读写位置移到文件尾时:

lseek（int fildes，0,SEEK_END）；

c、想要取得目前文件位置时:

lseek（int fildes，0,SEEK_CUR）；

返回值类型off_t ：

当调用成功时则返回目前的（读写位置），也就是距离文件开头多少个字节。若有错误则返回-1，errno 会存放错误代码。



2、用lseekh函数计算文件长度：

1）linux中并没有一个函数可以直接返回一个文件的长度(因为不需要)。但是我们实际使用时经常会需要知道一个文件的长度，怎么办？（我们可以利用lseek来写一个函数得到文件长度即可。）原理就是当我们新打开一个文件时，此时文件指针在文件最开头处，我们用lseek函数把文件指针移动到文件末尾处，然后返回值就是我们文件的末尾指针距离文件开头的偏移量，即文件的长度。



3、用lseek构建空洞文件：

什么是空洞文件？

通俗的讲就是一个文件里面有一段是空（其实这里的空洞文件时是指文件指针所指位置，也就是文件偏移量超出文件末尾了）；而普通文件中间是不能有空的，因为我们write时文件指针是依次从前到后去移动的，不可能绕过前面直接到后面（我们打开一个文件后，用lseek往后跳过一段，再write写入一段，就会构成一个空洞文件(这个空洞文件就是有一段没有内容。））。

注意：这里的空洞文件，在后面往文件里面写数据，会被文件系统看成'\0'做为返回值（'\0'表示空字符，不计入内存中），所以返回读取的内容为0，这也就能够解释为什么空洞这段空间写的数据并不会修改文件的大小。

空洞文件方法对多线程共同操作文件是及其有用的。有时候我们创建一个很大的文件(比如视频文件)，如果从头开始依次构建时间很长。有一种思路就是将文件分为多段，然后多线程来操作每个线程负责其中一段的写入。（就像修100公里的高速公路，分成20个段来修，每个段就只负责5公里，就可以大大提高效率）。

## 六、文件描述符和重定向

| 文件描述符 | 类型     | 描述                                   |
| :--------- | :------- | :------------------------------------- |
| 0          | stdin    | 标准输入流                             |
| 1          | stdout   | 标准输出流                             |
| 2          | stderr   | 标准错误流                             |
| 3+         | 普通文件 | 可通过系统调用`open()`获取的文件描述符 |

0,1,2对应的物理设备一般是:键盘，显示器，显示器。

文件描述符的分配规则:**在files_struct数组当中，找到当前没有被使用的最小的一个下标，作为新的文件描述符。**

**重定向**

- `>`：将输出重定向到文件，如果文件已存在则覆盖。
- `>>`：将输出重定向到文件，如果文件已存在则追加。

例如：

```shell
echo "Hello, World!" > output.txt
```

**重定向标准错误输出**

除了标准输出，还可以将标准错误输出（stderr）重定向到文件：

```cpp
echo "An error occurred" 2> error.txt
```

这将把标准错误输出写入到 `error.txt` 文件。

- **`1>`**（或省略为 `>`）：重定向正常输出流（stdout）。
- **`2>`**：仅重定向错误流（stderr）。

**同时重定向标准输出和标准错误输出**

有时，我们希望将标准输出和标准错误输出都重定向到同一个文件：

```cpp
echo "This is normal" > output.txt echo "This is an error" 2>> output.txt
```

**输入输出重定向**

重定向不仅仅用于输出，还可以用于输入。例如，我们可以使用 `<` 来将文件内容作为输入：

```cpp
cat < input.txt
```

**dup2系统调用来实现重定向**

```c
头文件
#include <unistd.h>

int dup2(int oldfd, int newfd);
将newfd重定向到oldfd。即原本指向oldfd的指针现在指向newfd
    
```



# Socket通信

## socket()

```c
int socket(int domain, int type, int protocol);
```

**1. domain (协议族/地址族)**

指定通信的协议族/地址族，常用的有：

- **AF_INET** / **PF_INET**: IPv4互联网协议(最常用)
- **AF_INET6** / **PF_INET6**: IPv6互联网协议
- **AF_UNIX** / **AF_LOCAL**: 本地通信(同一台主机上的进程间通信)
- **AF_PACKET**: 底层数据包接口(用于原始网络访问)

> 注意：AF_ (Address Family) 和 PF_ (Protocol Family) 在大多数实现中是等价的

**2. type (套接字类型)**

指定通信的语义(套接字类型)：

- **SOCK_STREAM**: 面向连接的字节流(TCP)
  - 可靠、双向、基于连接
  - 保证数据按序到达，无数据边界
- **SOCK_DGRAM**: 无连接的数据报(UDP)
  - 不可靠、有最大长度限制
  - 保留数据边界
- **SOCK_RAW**: 原始套接字
  - 允许直接访问底层协议
  - 需要特殊权限

**3. protocol (具体协议)**

通常设为0，表示根据前两个参数自动选择默认协议。也可以指定：

- **IPPROTO_TCP**: TCP协议(通常与SOCK_STREAM配合)
- **IPPROTO_UDP**: UDP协议(通常与SOCK_DGRAM配合)
- **IPPROTO_ICMP**: ICMP协议(用于ping等)

**返回值**

- 成功：返回一个非负整数的套接字描述符(类似于文件描述符)
- 失败：返回-1，并设置errno

当调用**socket**创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

#### `struct sockaddr_in` 结构体

`struct sockaddr_in` 是用于 IPv4 地址和端口号表示的核心数据结构，在网络编程中广泛使用。

```c
struct sockaddr_in {
    sa_family_t    sin_family;   // 地址族 (Address Family)
    in_port_t      sin_port;     // 16位端口号
    struct in_addr sin_addr;     // 32位IP地址
    char           sin_zero[8];  // 填充字段(未使用)
};

struct in_addr {
    in_addr_t      s_addr;       // 32位IPv4地址
};
```

## setsocket()

`setsockopt()` 是用于设置套接字选项的系统调用，可以配置套接字的各种行为特性。

```c
#include <sys/socket.h>

int setsockopt(int sockfd, int level, int optname,
              const void *optval, socklen_t optlen);
```

| 参数      | 说明                                       |
| :-------- | :----------------------------------------- |
| `sockfd`  | 套接字文件描述符                           |
| `level`   | 选项级别（如 `SOL_SOCKET`, `IPPROTO_TCP`） |
| `optname` | 选项名称                                   |
| `optval`  | 指向选项值的指针                           |
| `optlen`  | 选项值的长度                               |

| 选项           | 级别          | 用途            |
| :------------- | :------------ | :-------------- |
| `SO_REUSEADDR` | `SOL_SOCKET`  | 地址重用        |
| `SO_REUSEPORT` | `SOL_SOCKET`  | 端口重用        |
| `SO_KEEPALIVE` | `SOL_SOCKET`  | 保持连接        |
| `SO_LINGER`    | `SOL_SOCKET`  | 关闭行为        |
| `SO_SNDBUF`    | `SOL_SOCKET`  | 发送缓冲区大小  |
| `SO_RCVBUF`    | `SOL_SOCKET`  | 接收缓冲区大小  |
| `TCP_NODELAY`  | `IPPROTO_TCP` | 禁用 Nagle 算法 |

**返回值**

- **0**：成功设置套接字选项
- **-1**：获取选项失败，错误码在 `errno` 中

## getsockopt()

```c
#include <sys/socket.h>
//用于获取套接字选项当前值的系统调用。
int getsockopt(int sockfd, int level, int optname,
               void *optval, socklen_t *optlen);
```

| 参数      | 说明                                       |
| :-------- | :----------------------------------------- |
| `sockfd`  | 套接字文件描述符                           |
| `level`   | 选项级别（如 `SOL_SOCKET`, `IPPROTO_TCP`） |
| `optname` | 选项名称                                   |
| `optval`  | 指向存储选项值的缓冲区                     |
| `optlen`  | 输入：缓冲区大小，输出：实际值大小         |

**返回值**

- **0**：成功获取套接字选项
- **-1**：获取选项失败，错误码在 `errno` 中

## LingerVar()

`LingerVar` 是用于控制套接字关闭行为（ close() ）的结构体，与 `SO_LINGER` 选项配合使用。

```c
#include <sys/socket.h>

struct linger {
    int l_onoff;    // 0=关闭linger, 非0=开启linger
    int l_linger;   // 延迟时间（秒）
};
```

### 1. **默认模式** - 优雅关闭

```c
struct linger LingerVar;
LingerVar.l_onoff = 0;     // 关闭linger选项
LingerVar.l_linger = 0;    // 忽略此值

setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &LingerVar, sizeof(LingerVar));
```

**行为特点：**

- `close()` 立即返回
- 系统在后台尝试发送剩余数据
- 适用场景：大多数正常应用

### 2. **强制模式** - 立即关闭（代码中使用）

```c
struct linger LingerVar;
LingerVar.l_onoff = 1;     // 开启linger选项
LingerVar.l_linger = 0;    // 立即关闭，不等待

setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &LingerVar, sizeof(LingerVar));
```

**行为特点：**

- `close()` 立即返回
- **丢弃所有未发送数据**
- 发送 RST 包重置连接
- **适用场景**：连接测试、快速清理

### 3. **超时模式** - 有限等待

```c
struct linger LingerVar;
LingerVar.l_onoff = 1;     // 开启linger选项
LingerVar.l_linger = 5;    // 最多等待5秒

setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &LingerVar, sizeof(LingerVar));
```



**行为特点：**

- `close()` 会阻塞，直到：
  - 所有数据发送完毕并确认
  - 或超时时间到达
- 适用场景：重要数据传输

## bind()

**函数原型**

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

参数说明

1. **sockfd**

- 这是通过 `socket()` 函数创建的套接字描述符

2. **addr**

- 指向 `sockaddr` 结构体的指针，包含要绑定的地址和端口信息
- 实际使用时通常会使用 `sockaddr_in` (IPv4) 或 `sockaddr_in6` (IPv6) 结构体，然后强制转换为 `sockaddr*`

3. **addrlen**

- 指定 `addr` 结构体的大小（以字节为单位）

返回值

- 成功：返回 0
- 失败：返回 -1，并设置 errno

**IPv4 绑定示例**

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
	
    /*
    struct sockaddr_in {
    sa_family_t    sin_family;   // 地址族 (Address Family)
    in_port_t      sin_port;     // 16位端口号
    struct in_addr sin_addr;     // 32位IP地址
    char           sin_zero[8];  // 填充字段(未使用)
	};
	*/
    
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));//将0赋值到*serv_addr的前sizeof(serv_addr)位中
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;  // 绑定到所有可用接口
    serv_addr.sin_port = htons(8080);       // 绑定到8080端口

    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("bind failed");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 其他代码...
    close(sockfd);
    return 0;
}
```

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

## listen() 函数

### 功能

将套接字设置为被动模式，准备接受传入的连接请求。

### 函数原型

```
int listen(int sockfd, int backlog);
```

### 参数说明

1. **sockfd**:
   - 已经通过 `socket()` 创建并 `bind()` 的套接字描述符
2. **backlog**:
   - 等待连接队列的最大长度
   - 通常设置为 5-10，具体最大值取决于系统实现

### 返回值

- 成功：返回 0
- 失败：返回 -1，并设置 errno

### 常见用法

```c
if (listen(sockfd, 5) < 0) {
    perror("listen failed");
    exit(EXIT_FAILURE);
}
```

## connect() 函数

### 功能

客户端用于主动与服务器建立连接。

### 函数原型

```
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

### 参数说明

1. **sockfd**:
   - 客户端通过 `socket()` 创建的套接字描述符
2. **addr**:
   - 指向服务器地址结构的指针
   - 通常使用 `sockaddr_in` 结构体
3. **addrlen**:
   - 服务器地址结构的长度

### 返回值

- 成功：返回 0
- 失败：返回 -1，并设置 errno

### 常见用法

```c
struct sockaddr_in serv_addr;
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_port = htons(8080);

// 将IP地址从字符串转换为网络格式
if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
    perror("invalid address");
    exit(EXIT_FAILURE);
}
/*inet_pton() 是将人类可读的IP地址字符串转换为二进制网络格式的核心函数，是网络编程中处理IP地址的重要工具。
int inet_pton(int af, const char *src, void *dst);*/

if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0 {
    perror("connection failed");
    exit(EXIT_FAILURE);
}
```

## accept()

`accept()` 是 TCP 服务器编程中的核心函数，用于接受客户端的连接请求。下面我将全面解释这个函数的工作原理和使用方法。

### 函数原型

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

### 参数说明

1. **sockfd**:
   - 服务器监听套接字描述符（通过 `socket()` 创建，`bind()` 绑定，`listen()` 设置监听的套接字）
   - 必须是被动套接字（即已经调用过 `listen()`）
2. **addr** (可选):
   - 指向 `sockaddr` 结构体的指针，用于存储客户端地址信息
   - 可以设置为 NULL 表示不关心客户端地址
3. **addrlen** (可选):
   - 值-结果参数（value-result argument）
   - 调用前：设置为 `addr` 缓冲区的长度
   - 返回时：包含实际存储的地址长度
   - 如果 `addr` 为 NULL，可以设置为 NULL

### 返回值

- **成功**:
  - 返回一个新的套接字描述符（非负整数）
  - 这个新套接字专门用于与当前客户端通信
  - 原监听套接字继续用于接受其他连接
- **失败**:
  - 返回 -1，并设置 errno

### 基本工作流程

1. 客户端发起连接请求（`connect()`）
2. 服务器 `accept()` 接受连接
3. 系统创建新套接字与客户端通信
4. 原监听套接字继续监听新连接

## read()/write()

万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：

```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

1. **替代函数**:
   - `recv()`/`send()`: 提供额外标志参数
   - `recvmsg()`/`sendmsg()`: 更高级的I/O操作

## close()

在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。

```c
#include <unistd.h>int close(int fd);
```

close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。

注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。



# 网络通信

## 网关设置

| 网络类型           | 设备（dev） | 网关（via）    | 要求                       |
| :----------------- | :---------- | :------------- | :------------------------- |
| **以太网**（eth0） | 物理网卡    | 路由器IP       | 网关必须和设备在同一IP网段 |
| **点对点**（tun0） | 虚拟设备    | 对端IP         | 网关是虚拟的，实际不会访问 |
| **本地网络**       | 任何设备    | 无（可以省略） | 目标网络直接连接在该设备上 |

## A和B通过VPN数据传输

### A → B 数据发送流程

| 步骤            | 发生位置                 | 动作/封装变化                                                | 数据包内容（源 IP → 目标 IP） | 名称/注释                    |
| :-------------- | :----------------------- | :----------------------------------------------------------- | :---------------------------- | :--------------------------- |
| 1. 原始请求     | S_A (用户空间)           | 应用层构建请求数据                                           | ipA_LAN → ipB_LAN             | 原始数据请求                 |
| 2. 路由决策     | A 节点内核               | 路由决策，查路由表发往 ipB_LAN 走 tun0                       | ipA_LAN → ipB_LAN             | 数据包进入内核               |
| 3. SNAT 转换    | A 节点内核 (POSTROUTING) | SNAT 转换，源 IP 替换为 ipA_tun                              | ipA_tun → ipB_LAN             | data1 准备就绪（内层 IP 包） |
| 4. 写入 tun     | 内核 → tun0              | data1 写入 tun0 接口内核侧                                   | ipA_tun → ipB_LAN             | 裸 IP 包写入 tun             |
| 5. 隧道封装     | A 节点 OpenVPN           | OpenVPN 读取 data1，加密并添加隧道头                         | ipA_tun → ipB_LAN             | 成为 OpenVPN 载荷            |
| 6. 外层 IP 封装 | A 节点内核               | 外层 IP 封装（UDP/TCP 头 + 外层 IP 头）                      | ipA_eth0 → ipB_eth0           | data2 完成（外层 IP 包）     |
| 7. 传输         | 公网                     | data2 经 eth0 发往 B 节点                                    | ipA_eth0 → ipB_eth0           | 传输                         |
| 8. 外层解封     | B 节点内核               | 解封 data2，剥离外层 IP 头和端口头                           | ipA_tun → ipB_LAN             | OpenVPN 载荷交付用户空间     |
| 9. 隧道解密     | B 节点 OpenVPN           | 解密并剥离隧道头，还原 data1                                 | ipA_tun → ipB_LAN             | data1 还原                   |
| 10. 写入 tun    | OpenVPN → tun0           | data1 写入 tun0 接口内核侧                                   | ipA_tun → ipB_LAN             |                              |
| 11. 最终路由    | B 节点内核               | 路由决策，目标 ipB_LAN 转发到 eth1（如果S_B是本地应用，直接通过端口转发给S_B） | ipA_tun → ipB_LAN             | 转发                         |
| 12. S_B 接收    | S_B 服务器               | 接收数据包，源 IP 为 ipA_tun                                 | ipA_tun → ipB_LAN             |                              |

### B → A 数据响应流程

| 步骤             | 发生位置                 | 动作/封装变化                                                | 数据包内容（源 IP → 目标 IP） | 名称/注释                    |
| :--------------- | :----------------------- | :----------------------------------------------------------- | :---------------------------- | :--------------------------- |
| 13. 原始响应     | S_B (用户空间)           | 应用层构建响应数据                                           | ipB_LAN → ipA_tun             | S_B 响应                     |
| 14. 路由决策     | B 节点内核               | 路由决策，查路由表发往 ipA_tun 走 tun0                       | ipB_LAN → ipA_tun             |                              |
| 15. SNAT 转换    | B 节点内核 (POSTROUTING) | SNAT 转换，源 IP 替换为 ipB_tun                              | ipB_tun → ipA_tun             | data1 准备就绪（内层 IP 包） |
| 16. 写入 tun     | 内核 → tun0              | data1 写入 tun0 接口内核侧                                   | ipB_tun → ipA_tun             | 内核写 → tun 驱动            |
| 17. OpenVPN 读取 | B 节点 OpenVPN           | OpenVPN 从 tun0 读取 data1                                   | ipB_tun → ipA_tun             | OpenVPN 开始介入             |
| 18. 隧道封装     | B 节点 OpenVPN           | 加密并添加隧道头                                             | ipB_tun → ipA_tun             | 成为 OpenVPN 载荷            |
| 19. 外层 IP 封装 | B 节点内核               | 外层 IP 封装（UDP/TCP 头 + 外层 IP 头）                      | ipB_eth0 → ipA_eth0           | data2 完成（外层 IP 包）     |
| 20. 传输         | 公网                     | data2 经 eth0 发往 A 节点                                    | ipB_eth0 → ipA_eth0           | 传输                         |
| 21. 外层解封     | A 节点内核               | 解封 data2，剥离外层 IP 头和端口头                           | ipB_tun → ipA_tun             | OpenVPN 载荷交付用户空间     |
| 22. 隧道解密     | A 节点 OpenVPN           | 解密并剥离隧道头，还原 data1                                 | ipB_tun → ipA_tun             | data1 还原                   |
| 23. 写入 tun     | OpenVPN → tun0           | data1 写入 tun0 接口内核侧                                   | ipB_tun → ipA_tun             |                              |
| 24. 目标 DNAT    | A 节点内核 (PREROUTING)  | DNAT 转换，目标 IP 由 ipA_tun 替换为 ipA_LAN                 | ipB_tun → ipA_LAN             | DNAT 转换                    |
| 25. 最终路由     | A 节点内核               | 路由决策，目标 ipA_LAN 转发到 eth1（如果S_A是本地应用，直接通过端口转发给S_A） | ipB_tun → ipA_LAN             | 转发                         |
| 26. S_A 接收     | S_A 服务器               | 接收数据包，源 IP 为 ipB_tun                                 | ipB_tun → ipA_LAN             | 通信完成                     |

# IP数据包字节序

## 1. IPv4 头部（Header）

IPv4 头部位于数据包起始处，长度为 **20 ~ 60 字节**（由 IHL 指定），用于描述路由、协议类型和双方地址等基础信息。

你的代码中实际解析并使用了以下字段：

| **字节偏移** | **字段名称**                        | **代码中获取方式**                  | **说明**                                                     |
| ------------ | ----------------------------------- | ----------------------------------- | ------------------------------------------------------------ |
| 0            | 版本（Version） 头部长度（IHL）     | `packet[0] >> 4` `packet[0] & 0x0F` | 高 4 位表示 IP 版本（IPv4 = 4）； 低 4 位表示头部长度（单位为 4 字节）。 |
| 9            | 协议（Protocol）                    | `packet[9]`                         | 指明 IP 头部之后所承载的上层协议类型： • 6 → TCP • 17 → UDP • 1 → ICMP |
| 12–15        | 源 IP 地址（Source Address）        | `packet[12]` ~ `packet[15]`         | 发送方 IPv4 地址（每字节一个八位段）。                       |
| 16–19        | 目的 IP 地址（Destination Address） | `packet[16]` ~ `packet[19]`         | 接收方 IPv4 地址（每字节一个八位段）。                       |

### Version + IHL 字节结构说明（packet[0]）

```
bit:  7 6 5 4 | 3 2 1 0
      --------+---------
      Version |   IHL
```

------

## 2. IP 头部长度计算

IP 头部长度通过 IHL 字段计算：

```
int header_len = ihl * 4;
```

| IHL 值 | 实际 IP 头部长度          |
| ------ | ------------------------- |
| 5      | 20 字节（无选项，最常见） |
| >5     | 含 IP Options             |

------

## 3. 传输层头部及数据（Payload）

IP 头部结束后，紧跟传输层协议头部（TCP / UDP / ICMP 等）及应用层负载数据。

### TCP / UDP 端口字段字节序

你的代码在 TCP 或 UDP 场景下提取端口号：

| **字段**                     | **相对 IP 头部结束的偏移** | **代码位置**              | **说明**                  |
| ---------------------------- | -------------------------- | ------------------------- | ------------------------- |
| 源端口（Source Port）        | 0–1 字节                   | `packet + header_len`     | 16 位端口号（网络字节序） |
| 目的端口（Destination Port） | 2–3 字节                   | `packet + header_len + 2` | 16 位端口号（网络字节序） |

## 4. 字节序（Endianness）说明（非常重要）

### 网络字节序 vs 主机字节序

| 类型           | 字节序                    |
| -------------- | ------------------------- |
| 网络字节序     | Big-Endian（高位在前）    |
| x86 主机字节序 | Little-Endian（低位在前） |

因此：

- IP 地址的 **单字节字段**（如 `packet[12]`）无需转换
- **16/32 位字段**（端口号、长度、序号）必须使用字节序转换函数

### 端口号转换函数

```
ntohs()  // network → host（16 位）
ntohl()  // network → host（32 位）
```

> ⚠️ 若不使用 `ntohs`，在小端系统上读出的端口号数值将是错误的。

------

## 5. IPv4 + TCP / UDP 数据包整体字节布局示意

```
| IPv4 Header (ihl * 4 bytes) |
|   TCP / UDP Header         |
|       Payload Data         |
```

偏移关系（示例）：

```
packet + 0           → IPv4 Header
packet + header_len  → TCP / UDP Header
packet + ...         → Application Data
```

# C语言

## stderr和stdout

stderr不带缓冲；stdout带缓冲，需要读到'\n'或者缓存满了才会显示输出，可以使用fflush（）来刷新输出。

## 可变参数使用方法

**va_start(va_list args, last_fixed_param);**
第二个参数必须是最后一个固定参数的名称，不一定是参数数量
**va_arg(args, int);**
读取可变参数中下一个int类型
**va_end(args);**
调用va_end进行清理。

## feof()

用于**检测的是"上一次读取操作是否因为遇到文件尾而失败"（End Of File）**。

- **非0值**：已到达文件末尾
- **0**：未到达文件末尾

读取完最后一行之后，本次读取成功，指针到达EOF，但此时EOF标志还没设置。下一次feof()读取还会返回0。如果继续读取，fgets()读取，返回NULL，并设置EOF标志；fgetc()读取，返回0并设置EOF标志。下次feof()才会返回非0值。

```c
while(1){
  c = fgetc(fp);
  if( feof(fp) ){ 
      break ;
  }
  printf("%c", c);
}
   
  while(1){
  c = fgets(fp);
  if( feof(fp) ){ 
      break ;
  }
  printf("%s", c);
}

//或者fgetc：判断返回值是否为EOF
int c; // 必须是int，不能是char，为了正确接收EOF
while ((c = fgetc(fptr)) != EOF) {
    putchar(c);
}
// 循环结束后，可以用feof或ferror判断是正常结束还是出错
if (feof(fptr)) {
    printf("Reached end of file.\n");
} else if (ferror(fptr)) {
    printf("An error occurred.\n");
}

//fgets：判断返回值是否为NULL
char buffer[100];
while (fgets(buffer, 100, fptr) != NULL) {
    printf("%s", buffer);
}
if (feof(fptr)) {
    // 正常读到文件尾结束
} else {
    // 发生错误
}
```

## **abs()**

是 C 语言中用于计算整数绝对值的函数。返回整数 `n` 的绝对值（即非负值）

## **errno**

是一个全局变量，用于存储**最近一次系统调用或库函数调用产生的错误代码**。

## **select()**

用于 **I/O 多路复用** 的系统调用，可以同时监控多个文件描述符的状态。

```c
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
```

**参数说明**

| 参数        | 说明                            |
| :---------- | :------------------------------ |
| `nfds`      | 监控的最大文件描述符 + 1        |
| `readfds`   | 监控可读的文件描述符集合        |
| `writefds`  | 监控可写的文件描述符集合        |
| `exceptfds` | 监控异常的文件描述符集合        |
| `timeout`   | 超时时间（NULL=阻塞，0=非阻塞） |

**返回值**

- **> 0**：就绪的文件描述符数量
- **= 0**：超时
- **-1**：错误

`select()` 函数会**修改**传入的 `fd_set` 参数，只保留就绪的文件描述符。

## fcntl（）

```c
#include <unistd.h>
#include <fcntl.h>
//用于文件描述符控制的系统调用，可以操作文件描述符的各种特性
int fcntl(int fd, int cmd, ... /* arg */ );
```

| 参数  | 说明                   |
| :---- | :--------------------- |
| `fd`  | 文件描述符             |
| `cmd` | 控制命令               |
| `...` | 可变参数，取决于 `cmd` |

### fcntl() 常用命令表格

| 命令         | 用途               | 参数类型         | 返回值         | 示例                                    |
| :----------- | :----------------- | :--------------- | :------------- | :-------------------------------------- |
| **F_DUPFD**  | 复制文件描述符     | `int minfd`      | 新文件描述符   | `new_fd = fcntl(fd, F_DUPFD, 0);`       |
| **F_GETFD**  | 获取文件描述符标志 | 无               | 文件描述符标志 | `flags = fcntl(fd, F_GETFD);`           |
| **F_SETFD**  | 设置文件描述符标志 | `int flags`      | 0/-1           | `fcntl(fd, F_SETFD, FD_CLOEXEC);`       |
| **F_GETFL**  | 获取文件状态标志   | 无               | 文件状态标志   | `flags = fcntl(fd, F_GETFL);`           |
| **F_SETFL**  | 设置文件状态标志   | `int flags`      | 0/-1           | `fcntl(fd, F_SETFL, flags|O_NONBLOCK);` |
| **F_GETLK**  | 测试文件锁         | `struct flock *` | 0/-1           | `fcntl(fd, F_GETLK, &lock);`            |
| **F_SETLK**  | 设置非阻塞文件锁   | `struct flock *` | 0/-1           | `fcntl(fd, F_SETLK, &lock);`            |
| **F_SETLKW** | 设置阻塞文件锁     | `struct flock *` | 0/-1           | `fcntl(fd, F_SETLKW, &lock);`           |
| **F_GETOWN** | 获取异步I/O所有者  | 无               | 进程/组ID      | `owner = fcntl(fd, F_GETOWN);`          |
| **F_SETOWN** | 设置异步I/O所有者  | `int pid`        | 0/-1           | `fcntl(fd, F_SETOWN, getpid());`        |

### 文件状态标志

| 标志         | 说明       |
| :----------- | :--------- |
| `O_RDONLY`   | 只读       |
| `O_WRONLY`   | 只写       |
| `O_RDWR`     | 读写       |
| `O_NONBLOCK` | 非阻塞 I/O |
| `O_APPEND`   | 追加模式   |
| `O_ASYNC`    | 异步 I/O   |
| `O_DIRECT`   | 直接 I/O   |

## atoi（）

用于将一个**字符串**（ASCII码表示的数字）转换成对应的**整数**（integer）值。

```c
int atoi(const char *str);
```

## strncat（）

用于将一个字符串的**最多 n个字符**追加（连接）到另一个字符串的末尾

```c
char *strncat(char *dest, const char *src, size_t n);
```

## inet_pton（）

主要用于**网络编程**中，执行IP地址的**文本表示到数值表示**的转换。

它的名字是 "**inet**work **p**resentation **to** **n**umeric"（网络文本表示到数值）的缩写。

```c
int inet_pton(int af, const char *src, void *dst);
```

| **参数**  | **类型**       | **描述**                                                     |
| --------- | -------------- | ------------------------------------------------------------ |
| **`af`**  | `int`          | **地址族（Address Family）**：指定IP地址的版本。必须是以下两个值之一： <br />* **`AF_INET`**：用于 IPv4 地址（如 "192.168.1.1"）。<br />* **`AF_INET6`**：用于 IPv6 地址（如 "2001:db8::1"）。 |
| **`src`** | `const char *` | **源地址**：指向包含 IP 地址**文本字符串**（点分十进制或冒号分隔的十六进制）的缓冲区。 |
| **`dst`** | `void *`       | **目的地址**：指向用于存储转换后 IP 地址**二进制数值**（网络字节序）的缓冲区。 |

### IP 地址转换函数中的 A, P, N 总结

这三个字母代表了 $\text{IP}$ 地址的两种主要表示形式（文本或数值）及其演进过程。

| 字母 | 含义 (英文)     | 含义 (中文) | 对应的 IP 格式                              | 代表函数              | 协议兼容性   | 备注                                   |
| ---- | --------------- | ----------- | ------------------------------------------- | --------------------- | ------------ | -------------------------------------- |
| N    | Numeric         | 数值表示    | 4 或 16 字节二进制数据（网络字节序）        | inet_pton / inet_ntop | IPv4 / IPv6  | 计算机和网络设备使用的格式             |
| P    | Presentation    | 文本表示    | 点分十进制 (IPv4) 或冒号分隔十六进制 (IPv6) | inet_pton / inet_ntop | IPv4 和 IPv6 | 现代标准，强调格式可扩展性             |
| A    | Ascii / Address | 文本表示    | 仅限点分十进制 (IPv4)                       | inet_ntoa / inet_addr | 仅 IPv4      | 传统/过时，函数非线程安全且不支持 IPv6 |

## recvfrom（）

用于从**无连接的套接字**（通常是 UDP 套接字）接收数据，同时还能获取到发送方的地址信息

```c
ssize_t recvfrom(int sockfd, 
                 void *buf, 
                 size_t len, 
                 int flags, 
                 struct sockaddr *src_addr, 
                 socklen_t *addrlen);
```

| **参数**       | **类型**            | **描述**                                                     |
| -------------- | ------------------- | ------------------------------------------------------------ |
| **`sockfd`**   | `int`               | **套接字文件描述符**。通常是通过 `socket()` 创建的 `UDP` 套接字。 |
| **`buf`**      | `void *`            | **接收缓冲区**。指向用于存储接收到的数据的内存区域的指针。   |
| **`len`**      | `size_t`            | **缓冲区大小**。指定接收缓冲区 `buf` 的最大字节数。          |
| **`flags`**    | `int`               | **接收标志位**。用于修改接收行为，通常设置为 0。常用的标志有 `MSG_PEEK`（查看数据但不取出）和 `MSG_WAITALL` （等待接收到所有请求的数据）。 |
| **`src_addr`** | `struct sockaddr *` | **发送方地址结构**。指向一个 sockaddr 结构的指针。函数会将发送该数据包的**对等端的地址信息**（IP 和端口）填充到这个结构中。 |
| **`addrlen`**  | `socklen_t *`       | **地址长度指针**。指向一个整数的指针，用于： 1. **调用前：** 存储 `src_addr` 结构体的**初始大小**。 2. **返回后：** 存储内核实际写入 `src_addr` 结构体的**有效大小**。 |

# C++

## 类型转换

```c++
static_cast<新类型>(表达式)

//例子
double d = 3.14;
int i = static_cast<int>(d);    // 3
```



# C线程并发

## 创建线程

### 1. pthread_create()

pthread_create() 用来创建线程，创建成功后，线程就开始运行，
pthread_create() 调用成功后，会返回 0，否则返回错误码。

函数头文件:

```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
```

参数说明:

- thread: 指向 pthread_t 类型的指针，用来存储线程的 ID。
- attr: 线程属性，可以为 NULL，表示使用默认属性。
- - 线程属性:
- start_routine: 线程的入口函数.
- arg: 传递给线程入口函数的参数。没有参数可以传递 NULL。

返回值:

- 0: 创建成功。
- 失败: 返回错误码。(并非重置errno的值)
- EAGAIN: 资源不足，创建线程失败。
- EINVAL: 参数无效。
- ENOMEM: 内存不足，创建线程失败。

注意:

- 一旦子线程创建成功,则会被独立调度执行,并且与其他线程 并发执行
- 在编译时需要链接 -lpthread 库。
- 线程的入口函数必须声明为 void * 类型的函数指针。
- 线程的入口函数的参数类型必须与 pthread_create() 函数的 arg 参数类型一致。

#### 示例:创建一个线程

```c
// todo : 创建一个线程，并在线程中打印出“Hello, World!”
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {
   
   
    printf("%s\n",(char *)arg);
}

int main() {
   
   
    pthread_t tid; //? typedef unsigned long int pthread_t;
    // 创建线程
    //@param tid 线程ID
    //@param attr 线程属性
    //@param start_routine 线程函数
    //@param arg 线程函数参数
    int ret = pthread_create(&tid, NULL,print_hello, "Hello, World!");
    if (ret!= 0){
   
   
        printf("pthread_create error!\n");
        return 1;
    }
    sleep(1); // 等待线程执行完毕
    return 0;
}
```

### 2. pthread_exit() 退出线程

pthread_exit() 用来退出线程，线程执行完毕后，会自动调用 pthread_exit() 退出。

函数头文件:

```c
#include <pthread.h>

void pthread_exit(void *retval);
```

参数说明:

- retval: 线程退出时返回的值。
- 线程函数执行完毕后，会自动调用 pthread_exit() 退出。

### 3. pthread_join() 等待线程结束

pthread_join() 用来等待线程结束，
调用 pthread_join() 后，当前线程会被阻塞，直到线程结束。

函数头文件:

```c
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
```

参数说明:

- thread: 线程 ID。
- retval: 指向线程返回值的指针，用来存储线程退出时返回的值。(二级指针)

返回值:

- 0: 等待成功。
- EINVAL: 参数无效。
- ESRCH: 线程 ID 不存在。
- EDEADLK: 线程处于死锁状态。

#### 示例:

```c
// todo : 创建一个线程，并在线程中打印出“Hello, World!”
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {
   
   
    sleep(1); // 休眠1秒
    printf("%s\n",(char *)arg);
    pthread_exit(NULL); // 线程退出
}

int main() {
   
   
    pthread_t tid; //? typedef unsigned long int pthread_t;
    // 创建线程
    //* @param tid 线程ID
    //* @param attr 线程属性
    //* @param start_routine 线程函数
    //* @param arg 线程函数参数
    int ret = pthread_create(&tid, NULL,print_hello, "Hello, World!");
    if (ret!= 0){
        printf("pthread_create error!\n");
        return 1;
    }

    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tid, NULL);

    return 0;
}
等待线程结束...
Hello, World!
```

### pthread_cancel() 取消线程

pthread_cancel() 用来取消线程，
调用 pthread_cancel() 后，线程会被取消，不会被执行。
目标线程是否以及何时响应取决于 state 和 type 两个参数。

> 设置 state 使用 pthread_setcancelstate() 函数，设置 type 使用 pthread_setcanceltype() 函数。

函数头文件:

```c
#include <pthread.h>

int pthread_cancel(pthread_t thread);
```

参数说明:

- thread: 线程 ID。

返回值:

- 0: 取消成功。
- 失败: 返回错误码

### pthread_testcancel()函数

手动添加检查点

### pthread_setcancelstate() 函数

pthread_setcancelstate() 函数用来设置线程取消状态。

函数头文件:

```c
#include <pthread.h>

int pthread_setcancelstate(int state, int *oldstate);

相关宏定义:

PTHREAD_CANCEL_DISABLE: 禁止取消
PTHREAD_CANCEL_ENABLE: 启用取消 -- 默认
enum
{
   
   
  PTHREAD_CANCEL_ENABLE,
#define PTHREAD_CANCEL_ENABLE   PTHREAD_CANCEL_ENABLE
  PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCEL_DISABLE  PTHREAD_CANCEL_DISABLE
};
```

参数说明:

- state: 线程取消状态。
- oldstate: 指向原来的线程取消状态的指针。

返回值:

- 0: 设置成功。
- 失败: 返回错误码。

### pthread_setcanceltype() 函数

pthread_setcanceltype() 函数用来设置线程取消类型。

函数头文件:

```c
#include <pthread.h>

int pthread_setcanceltype(int type, int *oldtype);
相关宏定义:

PTHREAD_CANCEL_ASYNCHRONOUS: 立即取消
PTHREAD_CANCEL_DEFERRED: 延迟取消 -- 默认

enum
{
   
   
  PTHREAD_CANCEL_DEFERRED,
#define PTHREAD_CANCEL_DEFERRED    PTHREAD_CANCEL_DEFERRED
  PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_ASYNCHRONOUS    PTHREAD_CANCEL_ASYNCHRONOUS
};
```

参数说明:

- type: 线程取消类型。
- oldtype: 指向原来的线程取消类型的指针。

返回值:

- 0: 设置成功。
- 失败: 返回错误码。

#### 基础用法

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void* thread_func(void* arg) {
    // 必须设置取消点才能响应取消
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);

    while(1) {
        printf("Working...\n");
        sleep(1);
        pthread_testcancel(); // 显式创建取消点
    }
    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, thread_func, NULL);

    sleep(3);
    pthread_cancel(tid);  // 发送取消请求
    pthread_join(tid, NULL);
    printf("Thread canceled\n");
    return 0;
}
```

#### 1. 取消点（Cancellation Points）

- 系统定义的检查点：`sleep()`, `read()`, `write()`, `printf()` 等
- 手动检查：`pthread_testcancel()`
- 完整列表参见 `man 7 pthreads`



## 线程分离

***线程分为可结合的与可分离的\***

### pthread_detach()函数

pthread_detach()函数用来将线程分离，使得线程在创建后不会等待其结束，而是由操作系统自行回收资源。

参数:

- thread: 线程 ID。

返回值:

- 0: 分离成功。
- 失败: 返回错误码。(并非重置errno的值)

### 线程结合与分离的区别

- 可结合
  - 可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。
  - 线程创建的默认状态为 可结合的，可以由其他线程调用 pthread_join 函数等待子线程退出并释放相关资源
- 可分离
  - 不能被其他线程回收或者杀死的，该线程的资源在它终止时由系统来释放。

```c
// todo : 创建一个线程，并在线程中打印出“Hello, World!”
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {
   
   
    //线程分离的第二种方式
    //pthread_detach(pthread_self());

    sleep(1); // 休眠1秒
    printf("%s\n",(char *)arg);
    pthread_exit(NULL); // 线程退出
}

int main() {
   
   
    pthread_t tid; //? typedef unsigned long int pthread_t;
    // 创建线程
    //* @param tid 线程ID
    //* @param attr 线程属性
    //* @param start_routine 线程函数
    //* @param arg 线程函数参数
    int ret = pthread_create(&tid, NULL,print_hello, "Hello, World!");
    if (ret!= 0){
        printf("pthread_create error!\n");
        return 1;
    }

    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    //pthread_join(tid, NULL);//! 阻塞等待线程结束，直到线程结束后才继续往下执行

    //线程分离
    pthread_detach(tid); //! 分离线程，不用等待线程结束后才退出程序,该线程的资源在它终止时由系统来释放。

    printf("主线程结束\n");
    return 0;
}
```

## 创建多个线程

### 示例 1:创建多个线程执行不同的任务

```c
// todo : 创建多个线程,执行不同的任务
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程函数
//@param arg 线程函数参数
void * print_hello_A(void *arg) {
   
   
    sleep(1); // 休眠1秒
    printf("%s\n",(char *)arg);
    pthread_exit(NULL); // 线程退出
}
// 线程函数
//@param arg 线程函数参数
void * print_hello_B(void *arg) {
   
   
    sleep(2); // 休眠2秒
    printf("%s\n",(char *)arg);
    pthread_exit(NULL); // 线程退出
}


int main() {
   
   
    pthread_t tidA; //? 存储线程ID  typedef unsigned long int pthread_t;
    pthread_t tidB;
    // 创建线程
    //* @param tid 线程ID
    //* @param attr 线程属性
    //* @param start_routine 线程函数
    //* @param arg 线程函数参数
    int retA = pthread_create(&tidA, NULL,print_hello_A, "A_ Hello, World!");
    if (retA!= 0){
        printf("pthread_create error!\n");
        return 1;
    }

    int retB = pthread_create(&tidB, NULL,print_hello_B, "B_ Hello, World!");
    if (retB!= 0){
        printf("pthread_create error!\n");
        return 1;
    }

    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tidA, NULL);//! 阻塞等待线程结束，直到线程结束后才继续往下执行
    pthread_join(tidB, NULL);
    printf("主线程结束\n");
    return 0;
}
```

### 示例 2:创建多个线程执行相同的任务

```c
// todo : 创建多个线程,执行相同任务
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
//? 两个线程执行相同任务,对函数中的值修改了,会不会影响到其他线程的执行?
//! 在多线程编程中，如果多个线程执行相同的任务并且对共享资源进行修改，可能会影响到其他线程的执行。
//! 这是因为多个线程共享相同的内存空间，对共享资源的修改可能会导致竞态条件（race condition），
//! 从而导致不可预测的行为。
//! print_hello函数中的变量i是局部变量，每个线程都会有自己的i副本，因此对i的修改不会影响到其他线程。
//! 但是，如果涉及到共享资源（例如全局变量或静态变量），就需要考虑线程同步的问题，以避免竞态条件。


//*局部变量：每个线程都有自己的栈空间，因此局部变量是线程私有的，不会影响到其他线程。
//*共享资源：如果多个线程访问和修改同一个全局变量或静态变量，就需要使用同步机制（如互斥锁、信号量等）来确保线程安全。
//Linux：在Linux系统中，默认的线程栈大小通常是8MB。可以使用ulimit -s命令查看和修改当前用户的线程栈大小。例如，ulimit -s 1024将线程栈大小设置为1MB。
//Windows：在Windows系统中，默认的线程栈大小是1MB。可以通过编译器选项或在创建线程时指定栈大小来修改。

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {

    for (char i = 'a'; i < 'z' ; ++i) {
        printf("%c\n", i);
        sleep(1); // 休眠1秒
    }
    pthread_exit(NULL); // 线程退出
}

int main() {
    pthread_t tid[2]={0}; //? 存储线程ID的数组  typedef unsigned long int pthread_t;


    for (int i = 0; i < 2; ++i) {
        // 创建线程
        //* @param tid 线程ID
        //* @param attr 线程属性
        //* @param start_routine 线程函数
        //* @param arg 线程函数参数
        int retA = pthread_create(&tid[i], NULL,print_hello, NULL);
        if (retA!= 0){
            printf("pthread_create error!\n");
            return 1;
        }
    }

    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tid[0], NULL);//! 阻塞等待线程结束，直到线程结束后才继续往下执行
    pthread_join(tid[1], NULL);


    printf("主线程结束\n");
    return 0;
}
```

## 线程间的通讯

进程间的其他通讯同样适用于线程间的通讯。

### 主线程向子线程传递参数

通过pthread_create()函数创建子线程时，pthread_create()的第四个参数是传递给子线程的函数的参数。

### 子线程向主线程传递参数

通过pthread_exit()函数退出子线程时，可以向主线程传递参数。

```c
void pth_exit(void *retval);
```

通过pthread_join()函数等待子线程结束时，获取子线程的返回参数.

```c
int pthread_join (pthread_t __th, void **__thread_return);
//二级指针获取到了pthread_exit()函数参数指针的指向地址，通过该地址可以获取到子线程的返回参数。
```

### 示例:

```c
// todo : 线程直接通讯,子线程向父线程传参
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {
   
   
    printf("子线程开始,结束之时传递参数100的地址\n");

    sleep(1); // 休眠1秒
    //! int num=100;//局部变量,函数结束释放内存
    static int num=100;//* 静态局部变量,函数结束不释放内存,延长生命周期
    pthread_exit(&num); // 线程退出
}



int main() {
    pthread_t tid; //? 存储线程ID  typedef unsigned long int pthread_t;
    // 创建线程
    //* @param tid 线程ID
    //* @param attr 线程属性
    //* @param start_routine 线程函数
    //* @param arg 线程函数参数
    int retA = pthread_create(&tid, NULL,print_hello, NULL);
    if (retA!= 0){
        printf("pthread_create error!\n");
        return 1;
    }



    printf("等待线程结束...\n");
    void* num;//获取子进程传递的参数,num指向了子进程传递的参数
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tid, (void **)&num);//! 阻塞等待线程结束，直到线程结束后才继续往下执行
    printf("子线程结束,传递的参数为%d\n",*(int*)num);
    printf("主线程结束\n");
    return 0;
}
```



## 线程互斥锁

互斥锁（Mutex）是一种同步机制，用来控制对共享资源的访问。

> 线程的主要优势在于，能够通过全局变量来共享信息, 不过这种便捷的共享是有代价的:
>
> 必须确保多个线程不会同时修改同⼀变量
>
> 某⼀线程不会读取正由其他线程修改的变量, 实际就是不能让两个线程同时对临界区进⾏访问
>
> ## 互斥锁的原理

互斥锁的原理是，当一个线程试图进入一个互斥区时，如果该互斥区已经被其他线程占用，则该线程将被阻塞，直到互斥区被释放。

> 本质上是一个pthread_mutex_t类型的变量，它包含一个整数值，用来表示互斥区的状态。
> 当值为1时,则表示当前临界资源可以竞争访问,得到互斥锁的线程可以进入临界区。此时值为0,其他线程只能等待.
> 当值为0时,则表示当前临界资源被其他线程占用,不能进入临界区,只能等待.

### 互斥锁的特点

```c
typedef union
{
   
   
  struct __pthread_mutex_s __data; // 互斥锁的结构体
  char __size[__SIZEOF_PTHREAD_MUTEX_T];// 互斥锁的大小
  long int __align;// 互斥锁的对齐
} pthread_mutex_t;
```

- 互斥锁是⼀个 pthread_mutex_t 型的变量, 就代表⼀个 互斥锁
- 如果两个线程访问的是同⼀个 pthread_mutex_t 变量，那么它们访问了同⼀个互斥锁
- 对应的变量定义在 pthreadtypes.h 头⽂件中, 是⼀个共⽤体中包含⼀个结构体

### 互斥锁的使用

线程互斥锁的初始化⽅式主要分为两种:

#### 静态初始化

- 定义 pthread_mutex_t 类型的变量，然后对其初始化为 PTHREAD_MUTEX_INITIALIZER.

  ```c
  pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER
  ```

#### 动态初始化

> 动态初始化动态初始化主要涉及两个函数 pthread_mutex_init 函数 与pthread_mutex_destroy 函数

##### pthread_mutex_init()函数

用来初始化互斥锁，它接受两个参数: 互斥锁的地址和互斥锁的属性。

函数头文件:

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```

参数说明:

- mutex: 指向 pthread_mutex_t 类型的指针，用来存储互斥锁的地址。
- attr: 互斥锁的属性，可以为 NULL，表示使用默认属性。

返回值:

- 0: 初始化成功。
- 失败返回错误码。

##### pthread_mutex_destroy()函数

用来销毁互斥锁，它接受一个参数: 互斥锁的地址。

函数头文件:

```c
#include <pthread.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

参数说明:

- mutex: 指向 pthread_mutex_t 类型的指针，用来存储互斥锁的地址。

返回值:

- 0: 销毁成功。
- 失败返回错误码。

示例:

```c
// todo :  互斥锁;创建两个线程，分别对全局变量进⾏ +1 操作
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>


static int global = 0;// 全局变量

//静态初始化互斥锁
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 互斥锁
//动态初始化互斥锁
pthread_mutex_t mut;// 互斥锁

// 线程函数
//@param arg 线程函数参数
void * print_hello(void *arg) {
   
   
    printf("子线程开始\n");

    int loops = *(int *)arg;
    int i,tmp = 0;
    for (i = 0;i < loops;i++){
   
   
        pthread_mutex_lock(&mut);// 加锁
        printf("子线程%d,global=%d\n",i,global);
        tmp = global;
        tmp++;
        global = tmp;
        pthread_mutex_unlock(&mut);// 解锁
    }
    printf("子线程结束\n");
    pthread_exit(NULL); // 线程退出
}



int main() {
   
   

    // 动态初始化互斥锁
    //* @param mutex 互斥锁
    //* @param attr 互斥锁属性 NULL 是默认属性
    int r= pthread_mutex_init(&mut,NULL);
    if (r!= 0){
        printf("pthread_mutex_init error!\n");
        return 1;
    }

    pthread_t tid[2]={0}; //? 存储线程ID  typedef unsigned long int pthread_t;
    int arg=20;
    for (int i = 0; i < 2; i++){
        // 创建线程
        //* @param tid 线程ID
        //* @param attr 线程属性
        //* @param start_routine 线程函数
        //* @param arg 线程函数参数
        int retA = pthread_create(&tid[i], NULL,print_hello, &arg);
        if (retA!= 0){
            printf("pthread_create error!\n");
            return 1;
        }
    }




    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tid[0],NULL );//! 阻塞等待线程结束，直到线程结束后才继续往下执行
    pthread_join(tid[1],NULL );

    printf("%d\n",global);
    printf("主线程结束\n");

    // 销毁动态创建的互斥锁
    //* @param mutex 互斥锁
    pthread_mutex_destroy(&mut);// 销毁互斥锁

    return 0;
}
```

## 信号量

信号量本质上也是一个全局变量，不同与互斥锁的是，信号量的取值可以大于一，并且运行对信号量的值进行加和减。根据信号量初始值的不同，将其分为两类：

- 二进制信号量： 初始值为1 的信号量，因此该类信号量取值就只有1和0.此时信号量在功能上和互斥锁相同。
- 计数信号量： 初始值大于1的信号量，当当前进程中存在多个线程要访问某些公共资源，但资源数量小于线程数量，就可以用计数信号量来限制同时使用公共资源的线程数量。

根据使用场景的不同，信号量还可以分为：

- 无名信号量：只可以在共享内存的情况下，比如实现进程中各个线程之间的互斥和同步，因此无名信号量也被称作基于内存的信号量；

- 有名信号量：通常用于不共享内存的情况下，比如进程间通信。

  由于本文主要写线程间的同步机制，所以进程间通信问题不多赘述，有名信号量相关操作函数简单列出：

  ```c
  /* Open a named semaphore NAME with open flags OFLAG.  */
  extern sem_t *sem_open (const char *__name, int __oflag, ...)
    __THROW __nonnull ((1));
   
  /* Close descriptor for named semaphore SEM.  */
  extern int sem_close (sem_t *__sem) __THROW __nonnull ((1));
   
  /* Remove named semaphore NAME.  */
  extern int sem_unlink (const char *__name) __THROW __nonnull ((1));
  ```

信号量使用`sem_t`类型表示，该类型被定义在`<semaphore.h>` 头文件中。

以下是信号量的一些典型应用场景：

1. 系统中只有一台打印机，就可以设置初值为1的信号量，以实现对打印机的并发控制。
2. 环形队列和生产消费问题，这种情况下互斥锁适用于一整块临界资源，而信号量更适用于看似一块临界资源，但实际可以分成多个小部分的资源控制。
3. 线程同步，例如使用信号量控制两个线程间的同步，信号量的值初始化为0，表示没有信号量资源实例；尝试获取该信号量的线程会被阻塞，直到其他线程通过V操作释放信号量。
4. 控制线程开启的数量，如某一个界面需要同时发多个请求，全部请求都成功后再一起刷新界面的场景。

总的来说，信号量提供了一种高效而强大的并发控制手段，能够在多任务环境下保证对共享资源的合理分配和使用。

### 信号量的初始化

初始化信号量需要使用`sem_init()`函数进行，函数原型是：

```c
/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
   with other processes.  */
extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
  __THROW __nonnull ((1));
```

##### 参数

- `sem_t *__sem` 需要初始化的信号量
- `int __pshared` 是否和其他进程共享该信号量，0 表示不共享， 1 表示共享
- `unsigned int __value` 初始值

##### 返回值

初始化成功返回0，失败返回非0值

### 信号量的销毁

函数`sem_destroy()`原型：

```c
/* Free resources associated with semaphore object SEM.  */
extern int sem_destroy (sem_t *__sem) __THROW __nonnull ((1));
```

传入需要销毁的信号量， 销毁成功返回0，销毁失败返回非0值

### 等待信号量

其实这里将等待动作理解为占坑就可以，假设有三个坑，但是5个人。前三个人来之前查看坑的数量都是有坑的，那就自己占了。第四个人调用阻塞等待方式来查看还有没有坑，发现没了，但是他实在着急，于是就一直等着，工作也不干了。但是摸鱼的第五个人调用非阻塞等待方式来查看还有没有坑，发现没了，但是他不着急，他就回去了。

也就是其中一个线程去访问公共资源，由于该线程是被信号量限制的，所以该线程需要先等待信号量值大于1时才可以访问资源。等待信号量有两种方式：

- 阻塞等待 ： 线程查看信号量值是否大于1， 如果是，则将信号量减1并返回，程序继续运行；如果不是，则等待信号量的值变为1，等待过程中阻塞程序运行。

  `sem_wait()` 函数的原型是：

  ```c
  /* This function is a cancellation point and therefore not marked with
     __THROW.  */
  extern int sem_wait (sem_t *__sem) __nonnull ((1));
  ```

  该函数接收要等待的信号量，等待成功返回0，失败返回非0值。

- 非阻塞等待 ： 不管信号量的值是否大于1，非阻塞等待模式均直接返回。信号量大于1时，减 1 ，返回0；信号量小于1 时，直接返回非0.

  `sem_trywait()` 函数的原型是：

  ```c
  /* Test whether SEM is posted.  */
  extern int sem_trywait (sem_t *__sem) __THROWNL __nonnull ((1));
  ```

  该函数接收要等待的信号量，等待成功返回0，失败返回非0值。

### 释放信号量

前三个人占的坑逐渐使用完了，他们离开的动作就是对坑的释放。

`sem_post()` 函数的原型是：

```c
/* Post SEM.  */
extern int sem_post (sem_t *__sem) __THROWNL __nonnull ((1));
```

该函数接收待释放的信号量作为参数，释放成功返回0，释放失败返回非0值。

## 线程同步

> 线程同步 : 是指在互斥的基础上（⼤多数情况），通过其它机制实现访问者对 资源的有序访问.
>
> 条件变量 ： 线程库提供的专⻔针对线程同步的机制
>
> 线程同步⽐较典型的应⽤场合就是 ⽣产者与消费者

### ⽣产者与消费者问题

> 在这个模型中, 分为 ⽣产者线程 与 消费者线程, 通过这个线程来模拟多个线程同步的过程.
>
> > 在这个模型中, 需要以下组件:
> >
> > - 仓库 : ⽤于存储产品, ⼀般作为共享资源
> > - ⽣产者线程 : ⽤于⽣产产品
> > - 消费者线程 : ⽤于消费产品

原理:

当仓库没有产品时, 则消费者线程需要等待, 直到有产品时才能消费

当仓库已经装满产品时, 则⽣产者线程需要等待, 直到消费者线程消费产品之后

#### 示例 基于互斥锁实现⽣产者与消费者模型

> 主线程为消费者
>
> n 个⼦线程作为⽣产者

```c
// todo :  基于互斥锁实现⽣产者与消费者模型主线程为消费者,n 个⼦线程作为⽣产者
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
static int n = 0; // 产品数量
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 互斥锁

//生产者执行函数
void * dofunc(void *arg) {
   
   
    int arg1 = *(int*)arg;
    for (int i = 0; i <arg1; i++) {
   
   
        //获取互斥锁
        pthread_mutex_lock(&mutex);
        //生产产品
        printf("生产者%ld生产了%d个产品\n",pthread_self(),++n);//! pthread_self()返回当前线程ID
        //释放互斥锁
        pthread_mutex_unlock(&mutex);
        //休眠1秒
        sleep(1);
    }
    pthread_exit(NULL);
}


int main() {
   
   
    pthread_t tid[4]={0}; //? 存储线程ID  typedef unsigned long int pthread_t;
    int arr[4]={1,2,3,4};
    for (int i = 0; i < 4; i++) {
   
   
        // 创建线程
        //* @param tid 线程ID
        //* @param attr 线程属性
        //* @param start_routine 线程函数
        //* @param arg 线程函数参数
        int retA = pthread_create(&tid[i], NULL,dofunc,&arr[i] );
        if (retA!= 0){
            printf("pthread_create error!\n");
            return 1;
        }
    }
    //消费者执行

    for (int i = 0;i<10;i++) {
        //获取互斥锁
        pthread_mutex_lock(&mutex);
        while (n > 0){
            //消费产品
            printf("消费者%ld消费了1个产品:%d\n",pthread_self(),n--);
        }
        //释放互斥锁
        pthread_mutex_unlock(&mutex);
        //休眠1秒
        sleep(1);
    }


    printf("等待线程结束...\n");
    // 等待线程结束
    //* @param thread 线程ID
    //* @param status 线程退出状态
    pthread_join(tid[0],NULL );//! 阻塞等待线程结束，直到线程结束后才继续往下执行
    pthread_join(tid[1],NULL );
    pthread_join(tid[2],NULL );
    pthread_join(tid[3],NULL );

    return 0;
}
```

## 条件变量

条件变量是⼀种同步机制，它允许线程等待某个条件的⽬标满足后才继续运行。

条件变量的原理是，它包含一个互斥锁和一个等待队列。

互斥锁用于保护等待队列和条件变量。

![img_48.png](https://ucc.alicdn.com/pic/developer-ecology/hd64v2igxgssw_fd1e33d555424f7793ea28e2f2b418bb.png)

### 条件变量初始化

条件变量的本质为 pthread_cond_t 类型

```c
其他线程可以阻塞在这个条件变量上, 或者唤
醒阻塞在这个条件变量上的线程
typedef union
{
   
   
  struct __pthread_cond_s __data;
  char __size[__SIZEOF_PTHREAD_COND_T];
  __extension__ long long int __align;
} pthread_cond_t;
```

条件变量的初始化分为 静态初始化 与动态初始化

### 静态初始化

静态初始化的条件变量，需要先定义一个 pthread_cond_t 类型的变量，然后对其初始化为 PTHREAD_COND_INITIALIZER。

```c
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

### 动态初始化 pthread_cond_init()

动态初始化的条件变量，需要先定义一个 pthread_cond_t 类型的变量，然后调用 pthread_cond_init 函数对其进行初始化。

函数头文件:

```c
#include <pthread.h>

int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
```

参数说明:

- cond: 指向 pthread_cond_t 类型的指针，用来存储条件变量的地址。
- attr: 条件变量的属性，可以为 NULL，表示使用默认属性。

返回值:

- 0: 初始化成功。
- 失败返回错误码。

### pthread_cond_destroy()

用来销毁条件变量，它接受一个参数: 条件变量的地址。

函数头文件:

```c
#include <pthread.h>

int pthread_cond_destroy(pthread_cond_t *cond);
```

参数说明:

- cond: 指向 pthread_cond_t 类型的指针，用来存储条件变量的地址。

返回值:

- 0: 销毁成功。
- 失败返回错误码。

## 条件变量的使用

条件变量的使用分为 等待 与 通知

### 等待 pthread_cond_wait()

等待函数 pthread_cond_wait() 接受三个参数: 条件变量的地址、互斥锁的地址、等待时间。

函数头文件:

```c
#include <pthread.h>

int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
```

参数说明:

- cond: 指向 pthread_cond_t 类型的指针，用来存储条件变量的地址。
- mutex: 指向 pthread_mutex_t 类型的指针，用来存储互斥锁的地址。
- abstime: 超时时间，可以为 NULL，表示没有超时时间。

返回值:

- 0: 等待成功。
- 失败返回错误码。

### 通知 pthread_cond_signal()

通知函数
pthread_cond_signal() 接受一个参数: 条件变量的地址。

函数头文件:

```c
#include <pthread.h>

int pthread_cond_signal(pthread_cond_t *cond);
```

参数说明:

- cond: 指向 pthread_cond_t 类型的指针，用来存储条件变量的地址。

返回值:

- 0: 通知成功。
- 失败返回错误码。

### 通知所有 pthread_cond_broadcast()

通知所有函数
pthread_cond_broadcast() 接受一个参数: 条件变量的地址。

函数头文件:

```c
#include <pthread.h>

int pthread_cond_broadcast(pthread_cond_t *cond);
```

参数说明:

- cond: 指向 pthread_cond_t 类型的指针，用来存储条件变量的地址。

返回值:

- 0: 通知成功。
- 失败返回错误码。

### 示例 基于条件变量实现生产者与消费者模型

![img_49.png](https://ucc.alicdn.com/pic/developer-ecology/hd64v2igxgssw_b417db28fed7423da3e7ebd94675eb69.png?x-oss-process=image/resize,w_1400/format,webp)

```c
step 1 : 消费者线程判断消费条件是否满足 (仓库是否有产品)，如果有产品可以消费，则可以正
常消费产品，然后解锁
step 2 : 当条件不能满足时 (仓库产品数量为 0)，则调用 pthread_cond_wait 函数, 这个函数
            具体做的事情如下:
            在线程睡眠之前，对互斥锁解锁
            让线程进⼊到睡眠状态
            等待条件变量收到信号时 唤醒，该函数重新竞争锁，并获取锁后，函数返回 
step 3 ：重新判断条件是否满足, 如果不满足，则继续调用 pthread_cond_wait 函数
step 4 : 唤醒后，从 pthread_cond_wait 返回，消费条件满足，则正常消费产品
step 5 : 释放锁，整个过程结束
```

> 为什么条件变量需要与互斥锁结合起来使⽤?
>
> 保护共享数据：
>
> 互斥锁用于保护共享数据，确保在同一时间只有一个线程可以访问和修改这些数据。
>
> 这样可以避免数据竞争和不一致的问题。
>
> 条件变量用于线程间的通信，通知其他线程某个条件已经满足。
>
> 但是，条件变量的操作本身并不提供对共享数据的保护，因此需要与互斥锁结合使用。
>
> 避免虚假唤醒：
>
> 条件变量的一个特性是可能会发生虚假唤醒（Spurious Wakeup），
>
> 即线程在没有明确通知的情况下被唤醒。为了避免这种情况导致的错误操作，
>
> 线程在唤醒后需要重新检查条件是否真正满足。
>
> 使用互斥锁可以确保在检查条件时，共享数据不会被其他线程修改，从而避免因虚假唤醒导致的错误。
>
> 确保通知的正确性：
>
> 当一个线程通过条件变量通知其他线程时，需要确保在通知之前共享数据已经更新完毕。
>
> 互斥锁可以保证这一点，确保在释放锁之前所有数据更新操作都已经完成。
>
> 同样，接收通知的线程在检查条件之前也需要持有互斥锁，以确保在检查条件时数据是稳定的。
>
> 实现复杂的同步模式：
> 结合使用互斥锁和条件变量可以实现更复杂的同步模式，如生产者-消费者问题、读者-写者问题等。互斥锁保护共享数据，条件变量用于线程间的协调和通信。

```c
// todo :  条件变量
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdlib.h>


static int number = 0;// 产品数量
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;// 互斥锁
static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;// 条件变量

// 线程函数
//@param arg 线程函数参数
void * thread_handler(void *arg) {
   
   
    int cnt = atoi((char *)arg);// 获取线程参数
    int i,tmp;// 临时变量
    for(i = 0;i < cnt;i++){
   
   // 生产产品
        pthread_mutex_lock(&mtx);// 上锁
        printf("线程 [%ld] ⽣产⼀个产品,产品数量为:%d\n",pthread_self(),++number);
        pthread_mutex_unlock(&mtx);// 解锁

        //! 唤醒cond阻塞的线程
        //! @param cond 条件变量
        //pthread_cond_signal(&cond);//! 只能唤醒一个线程，如果有多个线程在等待，则只有一个线程会被唤醒
        //唤醒所有线程
        pthread_cond_broadcast(&cond);
    }
    pthread_exit((void *)0);// 线程退出
}



int main(int argc,char *argv[]) {
   
   

    pthread_t tid[argc-1];// 线程ID
    int i;
    int err;
    int total_of_produce = 0;// 总共生产的产品数量
    int total_of_consume = 0;// 总共消费的产品数量
    bool done = false;// 是否完成生产
    //循环创建线程
    for (i = 1;i < argc;i++){
   
   
        total_of_produce += atoi(argv[i]);// 计算总共需要生产的产品数量
        // 创建线程
        err = pthread_create(&tid[i-1],NULL,thread_handler,(void *)argv[i]);
        if (err != 0){
   
   
            perror("[ERROR] pthread_create(): ");
            exit(EXIT_FAILURE);
        }
    }
    //消费者
    for (;;){
   
   
        //*先获取锁,再进行条件变量的等待
        pthread_mutex_lock(&mtx);// 上锁

        //*while循环来判断条件,避免虚假唤醒
        while(number == 0) {// 等待生产者生产产品
            //! 等待条件变量
            //! @param cond 条件变量
            //! @param mtx 互斥锁
            //! 函数中会释放互斥锁，并阻塞线程，
            //! 直到条件变量被唤醒，再重新竞争互斥锁,获取互斥锁并继续执行
            pthread_cond_wait(&cond, &mtx);
        }
        while(number > 0){
            total_of_consume++;// 总共消费的产品数量
            printf("消费⼀个产品,产品数量为:%d\n",--number);// 消费产品
            done = total_of_consume >= total_of_produce;// 是否完成生产
        }
        pthread_mutex_unlock(&mtx);// 解锁

        if (done)// 是否完成生产
            break;
    }

    // 等待线程退出
    for(i = 0;i < argc-1;i++){
        pthread_join(tid[i],NULL);
    }

    return 0;

}
```

# 国密

## SM3

```c
#define SM3_DIGEST_SIZE		32
#define SM3_BLOCK_SIZE		64
#define SM3_STATE_WORDS		8
 
void sm3_init(SM3_CTX *ctx);
void sm3_update(SM3_CTX *ctx, const uint8_t *data, size_t datalen);
void sm3_finish(SM3_CTX *ctx, uint8_t dgst[SM3_DIGEST_SIZE]);
```

使用gmssl工具

测试代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gmssl/sm3.h>

#define BUF_SIZE 1024

//输出hash值
void print_hash(const char *msg, uint8_t *hash, size_t len)
{
    printf("%s: ", msg);
    for (size_t i = 0; i < len; ++i)
    {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

//计算文件的hash值
int computer_sm3_hash(const char *filename,uint8_t hash[SM3_DIGEST_SIZE])
{
    FILE *fp = fopen(filename, "rb");
    if (!fp)
    {
        printf("file open error\n");
        return -1;
    }

    uint8_t buffer[BUF_SIZE];
    size_t len;

    //初始化sm3上下文
    SM3_CTX ctx;
    sm3_init(&ctx);

    //循环读取文件数据
    while ((len = fread(buffer, 1, BUF_SIZE, fp)) > 0)
    {
        //计算sm3
        sm3_update(&ctx, buffer, len);//更新hash状态，参数是数据指针和长度
    }
    if(ferror(fp))
    {
        printf("file read error\n");
        fclose(fp);
        return -1;
    }
    
    sm3_finish(&ctx, hash);//完成计算，返回hash值
    fclose(fp);

    return 0;
}

int main(int argc, char *argv[])
{
    //参数检查
    if (argc != 3)
    {
        printf("用法: %s <文件1> <文件2>\n", argv[0]);
        return 1;
    }

    const char *file1 = argv[1];
    const char *file2 = argv[2];

    uint8_t hash1[SM3_DIGEST_SIZE];
    uint8_t hash2[SM3_DIGEST_SIZE];

    //分别计算两个文件的hash值
    if (computer_sm3_hash(file1, hash1) != 0)
    {
        printf("计算%s的hash值失败\n",file1);
        return 1;
    }
    if (computer_sm3_hash(file2, hash2) != 0)
    {
        printf("计算%s的hash值失败\n",file2);
        return 1;
    }

    //输出hash值
    print_hash("file1", hash1, SM3_DIGEST_SIZE);
    print_hash("file2", hash2, SM3_DIGEST_SIZE);

    //比较hash值
    if (memcmp(hash1, hash2, SM3_DIGEST_SIZE) == 0)
    {
        printf("文件%s和%s的hash值相同\n", file1, file2);
    }
    else
    {
        printf("文件%s和%s的hash值不相同\n", file1, file2);
    }
    return 0;
}
```



### 1. **普通 SM3 哈希计算接口**

```c
void sm3_init(SM3_CTX *ctx);
void sm3_update(SM3_CTX *ctx, const uint8_t *data, size_t datalen);
void sm3_finish(SM3_CTX *ctx, uint8_t dgst[SM3_DIGEST_SIZE]);
```

**用途**：这是最基础的 SM3 摘要计算接口，类似于 OpenSSL 的 `SHA256_Init/Update/Final`。

- `sm3_init`: 初始化上下文
- `sm3_update`: 可以分段输入数据（支持大数据或流式数据）
- `sm3_finish`: 计算并输出最终摘要（32 字节）

适合场景：普通哈希计算，如对文件内容、消息内容做摘要 

### 2. **SM3 HMAC（基于密钥的消息认证码）**

```c
void sm3_hmac_init(SM3_HMAC_CTX *ctx, const uint8_t *key, size_t keylen);
void sm3_hmac_update(SM3_HMAC_CTX *ctx, const uint8_t *data, size_t datalen);
void sm3_hmac_finish(SM3_HMAC_CTX *ctx, uint8_t mac[SM3_HMAC_SIZE]);
```

**用途**：基于密钥的哈希函数（HMAC），用于认证数据来源，防止被篡改。

- `key` 是共享的认证密钥
- `sm3_hmac_*` 过程与普通 `sm3_*` 类似，但内部用 key 混合处理

适合场景：消息认证、安全通信协议中的数据完整性校验（如 TLS）。

### 3. **SM3 KDF（密钥派生函数）**

```c
void sm3_kdf_init(SM3_KDF_CTX *ctx, size_t outlen);
void sm3_kdf_update(SM3_KDF_CTX *ctx, const uint8_t *in, size_t inlen);
void sm3_kdf_finish(SM3_KDF_CTX *ctx, uint8_t *out);
```

**用途**：从一个输入种子派生出多个字节的密钥（大于 32 字节）。

- `sm3_kdf_*` 使用 KDF（Key Derivation Function）算法，如 `KDF(Z, klen)`，生成指定长度的密钥流。
- `outlen` 是要生成的字节数，可大于 SM3 输出长度。

适合场景：密钥交换协议（如 SM2 密钥交换）中从共享秘密派生通信密钥。



## SM4

```c
#define SM4_KEY_SIZE		(16)
#define SM4_BLOCK_SIZE		(16)
#define SM4_NUM_ROUNDS		(32)
 
 
typedef struct {
	uint32_t rk[SM4_NUM_ROUNDS];
} SM4_KEY;
 
//密钥设置
void sm4_set_encrypt_key(SM4_KEY *key, const uint8_t raw_key[SM4_KEY_SIZE]);
void sm4_set_decrypt_key(SM4_KEY *key, const uint8_t raw_key[SM4_KEY_SIZE]);

//加密解密，对一个 16 字节块执行 SM4 加密
void sm4_encrypt(const SM4_KEY *key, const uint8_t in[SM4_BLOCK_SIZE], uint8_t out[SM4_BLOCK_SIZE]);
//加密解密同一个函数，但是key对象需要用不同函数来设置。
//in 和 out 都必须是 16 字节（SM4_BLOCK_SIZE = 16）；
```

CBC模式

```c
void sm4_cbc_encrypt_blocks(const SM4_KEY *key, uint8_t iv[SM4_BLOCK_SIZE],
	const uint8_t *in, size_t nblocks, uint8_t *out);
void sm4_cbc_decrypt_blocks(const SM4_KEY *key, uint8_t iv[SM4_BLOCK_SIZE],
	const uint8_t *in, size_t nblocks, uint8_t *out);
//处理一个或多个完整的块（通常每块是 16 字节）的加密/解密。
//加密和解密我vi需要一致
```

| 参数名    | 类型              | 说明                                                         |
| --------- | ----------------- | ------------------------------------------------------------ |
| `key`     | `const SM4_KEY *` | 已初始化的 SM4 密钥结构（使用 `sm4_set_encrypt_key()`）      |
| `iv`      | `uint8_t[16]`     | 初始化向量（Initial Vector），CBC 模式用来“链接”每个块。加密时会改变原内容；建议用临时变量传入 |
| `in`      | `const uint8_t *` | 明文（加密时）或密文（解密时）的输入数据指针                 |
| `nblocks` | `size_t`          | 要加密或解密的数据块数（一个块 = 16 字节）                   |
| `out`     | `uint8_t *`       | 输出加密/解密结果的缓冲区（大小必须为 `nblocks * 16` 字节）  |

### 带 padding 的函数

```c
void sm4_cbc_encrypt_blocks(const SM4_KEY *key, uint8_t iv[SM4_BLOCK_SIZE],
	const uint8_t *in, size_t nblocks, uint8_t *out);
void sm4_cbc_decrypt_blocks(const SM4_KEY *key, uint8_t iv[SM4_BLOCK_SIZE],
	const uint8_t *in, size_t nblocks, uint8_t *out);
```

- 自动处理**PKCS#7填充**（padding）；
- 输入数据 **可以不是 16 的整数倍**；
- 用于通用加密，比如加密字符串、文件、协议数据等；
- 输出的 `outlen` 是实际加密后的字节数（包括padding）；
- 推荐一般使用。

### SM4 CBC 模式分步式封装

```c
int sm4_cbc_encrypt_init(SM4_CBC_CTX *ctx, const uint8_t key[SM4_KEY_SIZE], const uint8_t iv[SM4_BLOCK_SIZE]);
int sm4_cbc_encrypt_update(SM4_CBC_CTX *ctx, const uint8_t *in, size_t inlen, uint8_t *out, size_t *outlen);
int sm4_cbc_encrypt_finish(SM4_CBC_CTX *ctx, uint8_t *out, size_t *outlen);

int sm4_cbc_decrypt_init(SM4_CBC_CTX *ctx, const uint8_t key[SM4_KEY_SIZE], const uint8_t iv[SM4_BLOCK_SIZE]);
int sm4_cbc_decrypt_update(SM4_CBC_CTX *ctx, const uint8_t *in, size_t inlen, uint8_t *out, size_t *outlen);
int sm4_cbc_decrypt_finish(SM4_CBC_CTX *ctx, uint8_t *out, size_t *outlen);
```

**SM4 CBC 模式加解密带自动填充（PKCS#5/#7）的分步式封装 API**，适用于加密大量数据（如文件）或流式数据场景。

## SM2

### 加密

```c
int sm2_encrypt(const SM2_KEY *key, const uint8_t *in, size_t inlen, uint8_t *out, size_t *outlen);

int sm2_encrypt(
    const SM2_KEY *key,        // 输入：SM2 公钥
    const uint8_t *in,         // 输入：明文数据
    size_t inlen,              // 输入：明文长度
    uint8_t *out,              // 输出：密文缓冲区（调用者分配），建议大小为 inlen + 97（SM2 最大密文长
    size_t *outlen             // 输出：密文长度
);
//成功：返回 1。失败：返回 0
```

### 解密

```c
int sm2_decrypt(
    const SM2_KEY *key,        // 输入：SM2 私钥
    const uint8_t *in,         // 输入：密文数据
    size_t inlen,              // 输入：密文长度
    uint8_t *out,              // 输出：解密结果缓冲区，建议大小为 密文长度 - 97。
    size_t *outlen             // 输出：解密结果长度
);
//成功：返回 1。失败：返回 0
```

### 签名

```c
int sm2_sign(
    const SM2_KEY *key,           // 输入：SM2 私钥
    const uint8_t dgst[32],       // 输入：SM3 摘要值（32 字节）
    uint8_t *sig,                 // 输出：签名数据（ASN.1 编码），建议缓冲区 ≥ 128 字节。
    size_t *siglen                // 输出：签名数据长度
);
//成功：返回 1。失败：返回 0
```

### 验证

```c
int sm2_verify(
    const SM2_KEY *key,           // 输入：SM2 公钥
    const uint8_t dgst[32],       // 输入：SM3 摘要值
    const uint8_t *sig,           // 输入：签名数据（ASN.1 DER 编码）
    size_t siglen                 // 输入：签名数据长度
);
//成功：返回 1。失败：返回 0
```

### 流式加解密

```c
int sm2_encrypt_init(SM2_ENC_CTX *ctx);
int sm2_encrypt_update(SM2_ENC_CTX *ctx, const uint8_t *in, size_t inlen);
int sm2_encrypt_finish(SM2_ENC_CTX *ctx, const SM2_KEY *public_key, uint8_t *out, size_t *outlen);
int sm2_encrypt_reset(SM2_ENC_CTX *ctx);

int sm2_decrypt_init(SM2_DEC_CTX *ctx);
int sm2_decrypt_update(SM2_DEC_CTX *ctx, const uint8_t *in, size_t inlen);
int sm2_decrypt_finish(SM2_DEC_CTX *ctx, const SM2_KEY *key, uint8_t *out, size_t *outlen);
int sm2_decrypt_reset(SM2_DEC_CTX *ctx);
```

### 流式签名验证

```c
int sm2_sign_init(SM2_SIGN_CTX *ctx, const SM2_KEY *key, const char *id, size_t idlen);
int sm2_sign_update(SM2_SIGN_CTX *ctx, const uint8_t *data, size_t datalen);
int sm2_sign_finish(SM2_SIGN_CTX *ctx, uint8_t *sig, size_t *siglen);
int sm2_sign_reset(SM2_SIGN_CTX *ctx);
int sm2_sign_finish_fixlen(SM2_SIGN_CTX *ctx, size_t siglen, uint8_t *sig);//生成固定长度签名

int sm2_verify_init(SM2_VERIFY_CTX *ctx, const SM2_KEY *key, const char *id, size_t idlen);
int sm2_verify_update(SM2_VERIFY_CTX *ctx, const uint8_t *data, size_t datalen);
int sm2_verify_finish(SM2_VERIFY_CTX *ctx, const uint8_t *sig, size_t siglen);
int sm2_verify_reset(SM2_VERIFY_CTX *ctx);
```



```c
int ***_reset(SM2_ENC_CTX *ctx);
//重置上下文，清空之前的数据。
```

# GTest

## 1. **`TEST`：基础独立测试**

- **用途**：定义**无需共享设置**的独立测试。

- **特点**：

  - 每个测试完全独立，不共享任何状态。
  - 适合简单、无依赖的测试场景。

- **语法**：

  cpp

  ```c++
  TEST(TestSuiteName, TestName) {
    // 测试逻辑
  }
  ```

- **示例**：

  cpp

  ```c++
  TEST(MathTest, Addition) {
    EXPECT_EQ(2 + 3, 5);
  }
  ```

## 2. **`TEST_F`：基于Fixture的测试**

- **用途**：定义**需要共享设置/资源**的测试（如数据库连接、配置初始化）。

- **特点**：

  - 依赖一个**测试夹具（Fixture）**（继承自`::testing::Test`的类）。
  - 每个测试运行前创建新的Fixture实例（调用`SetUp()`），结束后销毁（调用`TearDown()`）。
  - 测试间**状态隔离**（每个测试使用独立的Fixture实例）。

- **语法**：

  cpp

  ```
  TEST_F(TestFixtureClassName, TestName) {
    // 可访问Fixture的成员变量/函数
  }
  ```

- **示例**：

  cpp

  ```c++
  class DatabaseTest : public ::testing::Test {
   protected:
    void SetUp() override { db.Connect(); }
    void TearDown() override { db.Disconnect(); }
    Database db;
  };
  
  TEST_F(DatabaseTest, InsertData) {
    EXPECT_TRUE(db.Insert("data"));
  }
  ```

------

## 3. **`TEST_P`：参数化测试**

- **用途**：用**多组参数运行相同测试逻辑**（避免重复代码）。

- **特点**：

  - 依赖一个**参数化Fixture**（继承自`::testing::TestWithParam<T>`）。
  - 通过`GetParam()`获取当前参数值。
  - 需用`INSTANTIATE_TEST_SUITE_P`实例化参数组合。

- **语法**：

  cpp

  ```c++
  TEST_P(TestFixtureClassName, TestName) {
    T value = GetParam(); // 获取参数
  }
  ```

- **示例**：

  cpp

  ```c++
  class NumberTest : public ::testing::TestWithParam<int> {};
  
  TEST_P(NumberTest, IsPositive) {
    EXPECT_GT(GetParam(), 0);
  }
  
  INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,                  // 实例名称
    NumberTest,                       // 测试类名
    ::testing::Values(1, 2, 3)        // 参数列表
  );
  ```

### **1. 基本结构**

`TEST_P` 的使用通常涉及以下几个部分：

1. **定义参数化测试类**（继承 `::testing::TestWithParam<T>`）
2. **编写 `TEST_P` 测试用例**
3. **使用 `INSTANTIATE_TEST_SUITE_P` 实例化测试参数**

#### **示例代码**

```c++
#include <gtest/gtest.h>

// 1. 定义参数化测试类（T 是参数类型）
class MyParameterizedTest : public ::testing::TestWithParam<int> {
protected:
    void SetUp() override {
        // 可选的初始化代码
    }
    void TearDown() override {
        // 可选的清理代码
    }
};

// 2. 编写 TEST_P 测试用例
TEST_P(MyParameterizedTest, TestWithDifferentValues) {
    int param = GetParam(); // 获取当前参数
    EXPECT_GT(param, 0);    // 检查参数是否大于 0
}

// 3. 实例化测试参数
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,                     // 测试套件名称（可自定义）
    MyParameterizedTest,                 // 测试类名
    ::testing::Values(1, 2, 3, 10, 100)  // 参数列表
);
```

#### **执行结果**

- 该测试会为 `Values(1, 2, 3, 10, 100)` 中的每个参数生成一个独立的测试用例：

  ```c++
  [ RUN      ] PositiveNumbers/MyParameterizedTest.TestWithDifferentValues/0
  [       OK ] PositiveNumbers/MyParameterizedTest.TestWithDifferentValues/0 (0 ms)
  [ RUN      ] PositiveNumbers/MyParameterizedTest.TestWithDifferentValues/1
  [       OK ] PositiveNumbers/MyParameterizedTest.TestWithDifferentValues/1 (0 ms)
  ...
  ```

------

### **2. 参数来源**

`TEST_P` 支持多种参数生成方式：

#### **(1) `::testing::Values`（固定值列表）**

```c++
INSTANTIATE_TEST_SUITE_P(
    CustomName,
    MyParameterizedTest,
    ::testing::Values(1, 2, 3, 4, 5)
);
```

#### **(2) `::testing::Range`（数值范围）**

```c++
INSTANTIATE_TEST_SUITE_P(
    RangeTest,
    MyParameterizedTest,
    ::testing::Range(1, 10)  // 1, 2, ..., 9
);
```

#### **(3) `::testing::ValuesIn`（从容器获取参数）**

```c++
std::vector<int> testData = {10, 20, 30};
INSTANTIATE_TEST_SUITE_P(
    VectorTest,
    MyParameterizedTest,
    ::testing::ValuesIn(testData)
);
```

#### **(4) `::testing::Combine`（组合参数）**

```c++
INSTANTIATE_TEST_SUITE_P(
    CombinedTest,
    MyParameterizedTest,
    ::testing::Combine(
        ::testing::Values(1, 2),  // 第一组参数
        ::testing::Values('a', 'b')  // 第二组参数
    )
);
```

- 此时 `GetParam()` 返回 `std::tuple`，需要用 `std::get` 提取。

# JAVA

## 小知识

- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

  **`InputStreamReader`** - 字节流到字符流的桥梁，将字节转换成字符

  用来读取字符流，BufferedReader提供缓冲，支持readLine()等方法，效率更高

- String类型不可改变

# VPN

## 删除tun命令

```bash
#关闭vnet0
sudo ip link set vnet0 down

#删除vnet0
sudo ip link delete vnet0
```

## 添加/删除路由

向 **Linux 内核的路由表** 中添加一条路由记录

```bash
# ip 命令的等效写法（推荐）
sudo ip route add <目标网络地址>/<子网掩码> via <下一跳网关> dev <使用的网卡>
```

# strncasecmp和 strcmp比较

## strcmp

- **功能**：区分大小写的字符串比较
- **原型**：`int strcmp(const char *str1, const char *str2);`

## strncasecmp

- **功能**：不区分大小写的字符串比较，且限制比较长度
- **原型**：`int strncasecmp(const char *str1, const char *str2, size_t n);`

这是一份为您整理好的 C 语言可变参数（`stdarg.h`）使用指南，已经按照 Typora 的 Markdown 格式优化，您可以直接全选复制。

------





# C 语言可变参数 (stdarg.h) 学习笔记

在 C 语言中，处理参数个数不确定的函数（如 `printf`）时，需要使用 `<stdarg.h>` 头文件提供的宏。

## 1. 核心要素

实现可变参数函数需要以下 1 个类型和 4 个核心宏：

| **名称**       | **作用**                                                     |
| -------------- | ------------------------------------------------------------ |
| **`va_list`**  | 定义一个用于指向参数列表的变量（本质是一个指针）。           |
| **`va_start`** | **初始化**：使 `va_list` 指向第一个可变参数。                |
| **`va_arg`**   | **取值且移动**：获取当前参数值，并自动将指针移动到下一个参数。 |
| **`va_end`**   | **清理**：结束参数获取，释放资源，确保栈安全。               |
| **`va_copy`**  | **复制**：备份当前的参数列表状态。                           |

------

## 2. 标准使用流程

编写可变参数函数通常遵循以下四步曲：

```c
#include <stdarg.h>

void func(int last_fixed_arg, ...) {
    va_list ap;                 // 1. 定义指针
    va_start(ap, last_fixed_arg); // 2. 初始化，使其指向第一个可变参数
    
    // 3. 循环获取参数
    // type value = va_arg(ap, type); 
    
    va_end(ap);                 // 4. 清理指针
}
```

------

## 3. 代码示例：计算任意数量整数的和

这是一个最经典的入门例子。

```c
#include <stdio.h>
#include <stdarg.h>

/**
 * @param count 期望累加的整数个数
 * @param ...   具体的整数列表
 */
int sum_all(int count, ...) {
    va_list args;
    int total = 0;

    // 从 count 之后的第一个参数开始
    va_start(args, count);

    for (int i = 0; i < count; i++) {
        // va_arg 会自动移动指针到下一个参数
        total += va_arg(args, int);
    }

    // 清理工作
    va_end(args);

    return total;
}

int main() {
    int s1 = sum_all(3, 10, 20, 30);
    int s2 = sum_all(5, 1, 2, 3, 4, 5);
    
    printf("Sum 1: %d\n", s1); // 输出 60
    printf("Sum 2: %d\n", s2); // 输出 15
    return 0;
}
```

------

## 4. 重要特性与注意事项

### ① 指针自动偏移

- **`va_arg` 是消耗性的**：每调用一次 `va_arg(ap, type)`，`ap` 指针就会根据 `type` 的长度自动向后移动。
- **不可逆性**：指针只能向后移动。如果需要重新读取参数，必须再次调用 `va_start` 或使用 `va_copy` 提前备份。

### ② 默认参数提升 (Default Argument Promotions)

在可变参数传递中，C 语言会进行自动类型提升：

- `float` 会自动提升为 `double`。
- `char`、`short` 会自动提升为 `int`。
- **结论**：在 `va_arg(ap, type)` 中，`type` 建议使用 `int` 或 `double`，避免使用 `float` 或 `char`，否则可能读取错误数据。

### ③ 必须有固定参数

可变参数函数至少需要一个固定的参数（如上述例子中的 `count`），因为 `va_start` 需要通过最后一个固定参数的地址来定位后续可变参数在栈上的位置。

### ④ 结束判断

可变参数列表本身不知道长度。常用的解决办法有：

1. **传计数**：第一个参数指定后面有多少个参数（如上面的 `count`）。
2. **哨兵值**：在参数末尾传一个特殊值（如 `NULL` 或 `-1`）作为结束标记。
3. **格式化字符串**：像 `printf` 一样，通过解析第一个字符串里的 `%` 数量来确定。

------

## 5. 进阶：传递 va_list

如果你想把收到的参数再传给另一个函数（例如你自己写一个 `my_printf`），应该调用该函数的 `v` 版本。

```c
void my_log(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    
    printf("[LOG] ");
    vprintf(fmt, args); // 传递 va_list 给系统函数 vprintf
    
    va_end(args);
}
```





------

# 网络字节序与主机字节序笔记

## 1. 基本概念

字节序是指**多字节数据**（如 `int`, `short`）在内存中的**字节排列顺序**。

### 主机字节序 (Host Byte Order)

指特定计算机硬件体系结构所采用的存储方式，主要分为两类：

- **小端字节序 (Little-Endian)**：数据的**低位字节**存储在内存的**低地址**端。
  - *代表架构*：x86, x64, ARM（多数处于小端模式）。
- **大端字节序 (Big-Endian)**：数据的**高位字节**存储在内存的**低地址**端。
  - *代表架构*：早期的 PowerPC, Sun Sparc。

### 网络字节序 (Network Byte Order)

为了保证不同字节序的主机能正常通信，TCP/IP 协议规定：**网络数据传输必须采用“大端字节序”**。

- 发送方：如果是小端机，需先将数据转为大端再发送。
- 接收方：收到数据后，根据自身架构转回主机字节序。

------

## 2. 字节序直观对比

以十六进制数 `0x12345678` 为例，在内存中的存储顺序如下：

| **内存地址**        | **大端 (网络字节序)** | **小端 (常见 PC 主机)** |
| ------------------- | --------------------- | ----------------------- |
| **0x1000 (低地址)** | `0x12` (高位)         | `0x78` (低位)           |
| **0x1001**          | `0x34`                | `0x56`                  |
| **0x1002**          | `0x56`                | `0x34`                  |
| **0x1003 (高地址)** | `0x78` (低位)         | `0x12` (高位)           |

------

## 3. C 语言转换函数

在 `<arpa/inet.h>` 或 `<netinet/in.h>` 中，提供了一组转换宏/函数。

### 命名规则

- `h`：host（主机）
- `n`：network（网络）
- `s`：short（16位，用于端口号）
- `l`：long（32位，用于 IP 地址）

### 函数列表

| **函数**                                 | **作用**                         |
| ---------------------------------------- | -------------------------------- |
| **`uint16_t htons(uint16_t hostshort)`** | 主机字节序 -> 网络字节序 (short) |
| **`uint32_t htonl(uint32_t hostlong)`**  | 主机字节序 -> 网络字节序 (long)  |
| **`uint16_t ntohs(uint16_t netshort)`**  | 网络字节序 -> 主机字节序 (short) |
| **`uint32_t ntohl(uint32_t netlong)`**   | 网络字节序 -> 主机字节序 (long)  |

------

## 4. 为什么单字节不需要转换？

**`char` 类型不需要转换。**

字节序讨论的是“字节之间的顺序”。单个字节（8位）是数据的最小寻址单位，内部位偏移由硬件逻辑处理，在网络传输中不存在顺序歧义。只有涉及 `short`, `int`, `long` 等多字节组合时才需要考虑。

------

## 5. 快速代码测试：你的电脑是什么字节序？

C

```
#include <stdio.h>

int main() {
    unsigned int x = 0x12345678;
    unsigned char *p = (unsigned char *)&x;

    if (*p == 0x78) {
        printf("你的主机是：小端字节序 (Little-Endian)\n");
    } else {
        printf("你的主机是：大端字节序 (Big-Endian)\n");
    }
    return 0;
}
```

------

